import os
from files_manager import File, FilesList
from cvlib_enums import *

prostack_path = r'"C:\ProStack\bin\prostak.exe"'
image_magick_path = r'"C:\Program Files\ImageMagick\magick.exe"'


# generates the rules to put the image of Drosophila embryo into standard orientation
def align(input: File) -> FilesList:
	if input.format != 'tif':
		print('ERROR in align function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='align', formats='txt')
	command = prostack_path + ' -o align' + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# diffusion algorithms remove noise from an image by modifying the image via a partial differential equation (PDE)
def andif(input: File, iterations: int = 3, time_step: float = 0.9, threshold: float = 0.9, function_type: AndifFunction_typeEnum = AndifFunction_typeEnum.EXP) -> FilesList:
	if input.format != 'tif':
		print('ERROR in andif function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='andif', formats='tif')
	command = prostack_path + ' -o andif' + ' -s ' + str(iterations) + ',' + str(time_step) + ',' + str(threshold) + ',' + str(function_type.value) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# applies the rules to put the image of Drosophila embryo into standard orientation
def apee(inputs: FilesList, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in apee function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='apee', formats='tif')
	command = prostack_path + ' -o apee' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# checks the rules generated by align (see 8
def apsc(inputs: FilesList, direction: APEnum = APEnum.A) -> FilesList:
	if not inputs.check_formats('txt,txt'):
		print('ERROR in apsc function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='apsc', formats='txt')
	command = prostack_path + ' -o apsc' + ' -s ' + str(direction.value) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# subtracts the image dimensions that are given as a string of four numbers which are distances measured in pixels from the image center to its borders
def ar_minus(inputs: FilesList) -> FilesList:
	if not inputs.check_formats('txt,txt'):
		print('ERROR in ar_minus function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='ar_minus', formats='txt')
	command = prostack_path + ' -o ar_minus' + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# sums up the image dimensions that are given by a string of four numbers which are the distances measured in pixels from the image center to its borders
def ar_plus(inputs: FilesList) -> FilesList:
	if not inputs.check_formats('txt,txt'):
		print('ERROR in ar_plus function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='ar_plus', formats='txt')
	command = prostack_path + ' -o ar_plus' + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# multiplies by a constant the image dimensions given by a string of four numbers which are the distances measured in pixels from the image center to its borders
def ar_x(input: File, value: float = 1) -> FilesList:
	if input.format != 'txt':
		print('ERROR in ar_x function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='ar_x', formats='txt')
	command = prostack_path + ' -o ar_x' + ' -p ' + str(value) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# averages three images pixel by pixel
def avg(inputs: FilesList, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesList:
	if not inputs.check_formats('tif,tif,tif'):
		print('ERROR in avg function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='avg', formats='tif')
	command = prostack_path + ' -o avg' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# averages two images pixel by pixel
def avg2(inputs: FilesList, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesList:
	if not inputs.check_formats('tif,tif'):
		print('ERROR in avg2 function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='avg2', formats='tif')
	command = prostack_path + ' -o avg' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# converts the coordinates of centroids of blobs to polar coordinates
def blo2pol(inputs: FilesList) -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in blo2pol function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='blo2pol', formats='txt')
	command = prostack_path + ' -o blo2pol' + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# restores an image of blobs from the list stored in the input file
def bolb(input: File) -> FilesList:
	if input.format != 'txt':
		print('ERROR in bolb function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='bolb', formats='tif')
	command = prostack_path + ' -o bolb' + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# restores an image of the selected blob from the list stored in the input file
def bolin(input: File, index: int = 0) -> FilesList:
	if input.format != 'txt':
		print('ERROR in bolin function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='bolin', formats='tif')
	command = prostack_path + ' -o bolin' + ' -r ' + str(index) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# calculates the average intensity in the left and right parts of the image
def chemar(input: File) -> FilesList:
	if input.format != 'tif':
		print('ERROR in chemar function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='chemar', formats='txt')
	command = prostack_path + ' -o chemar' + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# fills the regions of 'off' pixels surrounded by 'on' pixels using a structural element
def chole(inputs: FilesList) -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in chole function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='chole', formats='tif')
	command = prostack_path + ' -o chole' + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# reduces the dimensions of the input image to the minimal rectangular area required to cover all 'on' pixels
def crop(input: File) -> FilesList:
	if input.format != 'tif':
		print('ERROR in crop function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='crop', formats='tif,txt')
	command = prostack_path + ' -o crop' + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# makes a watershed transformation of an input image
def cwtsd(input: File, connectivity: ConnectivityEnum = ConnectivityEnum.FOUR) -> FilesList:
	if input.format != 'tif':
		print('ERROR in cwtsd function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='cwtsd', formats='tif')
	command = prostack_path + ' -o cwtsd' + ' -r ' + str(connectivity.value) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# reduces the intensity of salt and pepper noise in an image using the Crimmins complementary hulling algorithm [1]
def despekle(input: File, iterations: int = 1) -> FilesList:
	if input.format != 'tif':
		print('ERROR in despekle function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='despekle', formats='tif')
	command = prostack_path + ' -o despekle' + ' -r ' + str(iterations) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# replaces the value of each pixel in the input image by the Euclidean distance from this pixel to the nearest 'off' pixel
def distance(input: File, window: DistanceTransformEnum = DistanceTransformEnum.THREE) -> FilesList:
	if input.format != 'tif':
		print('ERROR in distance function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='distance', formats='tif')
	command = prostack_path + ' -o distance' + ' -r ' + str(window.value) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# detects the edges of objects in the input image using the Shen-Castan Detector [5, 6]
def edge(input: File, a1: float = 0.76543, a2: float = 0.76543, low_threshold: float = 3, high_threshold: float = 12, window: int = 11, segment: int = 11, connectivity: ConnectivityEnum = ConnectivityEnum.FOUR) -> FilesList:
	if input.format != 'tif':
		print('ERROR in edge function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='edge', formats='tif')
	command = prostack_path + ' -o edge' + ' -s ' + str(a1) + ',' + str(a2) + ',' + str(low_threshold) + ',' + str(high_threshold) + ',' + str(window) + ',' + str(segment) + ',' + str(connectivity.value) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# increases the size of the input image using the pixel replication
def expand(input: File, scale_from_1: float = 2.0) -> FilesList:
	if input.format != 'tif':
		print('ERROR in expand function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='expand', formats='tif')
	command = prostack_path + ' -o expand' + ' -p ' + str(scale_from_1) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# fills the regions of 'off' pixels surrounded by 'on' pixels
def fill(input: File, connectivity: ConnectivityEnum = ConnectivityEnum.FOUR) -> FilesList:
	if input.format != 'tif':
		print('ERROR in fill function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='fill', formats='tif')
	command = prostack_path + ' -o fill' + ' -r ' + str(connectivity.value) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# does successive dilations of the input image by the structural element supplied as the second input
def gdilation(inputs: FilesList, repetitions: int = 1) -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in gdilation function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='gdilation', formats='tif')
	command = prostack_path + ' -o gdilation' + ' -r ' + str(repetitions) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# performs morphological opening which is the erosion followed by dilation using the structural element supplied as the second input
def gopen(inputs: FilesList, repetitions: int = 1) -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in gopen function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='gopen', formats='tif')
	command = prostack_path + ' -o gopen' + ' -r ' + str(repetitions) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# performs morphological closing which is the dilation followed by erosion using the structural element supplied as the second input
def gclose(inputs: FilesList, repetitions: int = 1) -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in gclose function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='gclose', formats='tif')
	command = prostack_path + ' -o gclose' + ' -r ' + str(repetitions) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# reduces dimensions of the input image
def geometry(inputs: FilesList, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in geometry function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='geometry', formats='tif')
	command = prostack_path + ' -o geometry' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# does successive erosions of the input image by the structural element supplied as the second input
def gerosion(inputs: FilesList, repetitions: int = 1) -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in gerosion function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='gerosion', formats='tif')
	command = prostack_path + ' -o gerosion' + ' -r ' + str(repetitions) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# calculates the magnitude of the gradient
def gmag(input: File) -> FilesList:
	if input.format != 'tif':
		print('ERROR in gmag function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='gmag', formats='tif')
	command = prostack_path + ' -o gmag' + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# prints dimensions of the image as a string of four numbers representing the distance in pixels from the image center to the borders
def halfsizes(input: File) -> FilesList:
	if input.format != 'tif':
		print('ERROR in halfsizes function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='halfsizes', formats='txt')
	command = prostack_path + ' -o halfsizes' + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# performs the histogram equalization taking into account only those pixels that are 'on' in the mask that comes from the second input
def heqm(inputs: FilesList) -> FilesList:
	if not inputs.check_formats('tif,tif'):
		print('ERROR in heqm function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='heqm', formats='tif')
	command = prostack_path + ' -o heq' + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# equalizes the histogram of the image
def heq(input: File) -> FilesList:
	if input.format != 'tif':
		print('ERROR in heq function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='heq', formats='tif')
	command = prostack_path + ' -o heq' + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# normalizes the histogram of the image
def hno(input: File) -> FilesList:
	if input.format != 'tif':
		print('ERROR in hno function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='hno', formats='tif')
	command = prostack_path + ' -o hno' + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# combines grayscale images of three color channels (Red, Green and Blue) to the one grayscale image in which each pixel equals the product of Hue and Saturation values in this pixel
def hues(inputs: FilesList) -> FilesList:
	if not inputs.check_formats('tif,tif,tif'):
		print('ERROR in hues function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='hues', formats='tif')
	command = prostack_path + ' -o hues' + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# inverts the grayscale values of all pixels in input image
def invert(input: File) -> FilesList:
	if input.format != 'tif':
		print('ERROR in invert function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='invert', formats='tif')
	command = prostack_path + ' -o invert' + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# those pixels that have the given intensity in the input image have the maximal intensity in the output image
def lev(input: File, index: int = 0) -> FilesList:
	if input.format != 'tif':
		print('ERROR in lev function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='lev', formats='tif')
	command = prostack_path + ' -o lev' + ' -r ' + str(index) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# performs histogram equalization separately for each pixel using the neighborhood defined by the structural element from the second input
def lheq(inputs: FilesList, repetitions: int = 1) -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in lheq function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='lheq', formats='tif')
	command = prostack_path + ' -o lheq' + ' -r ' + str(repetitions) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# estimates background for each pixel using the neighborhood defined by the structural element from the second input
def lhbg(inputs: FilesList) -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in lhbg function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='lhbg', formats='tif')
	command = prostack_path + ' -o lhbg' + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# masks the first input image by the second one
def mask(inputs: FilesList) -> FilesList:
	if not inputs.check_formats('tif,tif'):
		print('ERROR in mask function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='mask', formats='tif')
	command = prostack_path + ' -o mask' + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# computes pixel by pixel maximum of three input images
def max(inputs: FilesList, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesList:
	if not inputs.check_formats('tif,tif,tif'):
		print('ERROR in max function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='max', formats='tif')
	command = prostack_path + ' -o max' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# computes pixel by pixel maximum of two input images
def max2(inputs: FilesList, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesList:
	if not inputs.check_formats('tif,tif'):
		print('ERROR in max2 function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='max2', formats='tif')
	command = prostack_path + ' -o max' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# reduces the dimensions of the input image
def mcrop(input: File, upper_offset: int = 1, lower_offset: int = 1, left_offset: int = 1, right_offset: int = 1, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesList:
	if input.format != 'tif':
		print('ERROR in mcrop function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='mcrop', formats='tif')
	command = prostack_path + ' -o geometry' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' -s ' + str(upper_offset) + ',' + str(lower_offset) + ',' + str(left_offset) + ',' + str(right_offset) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# computes a two dimensional median filter of a structural element over the given image
def median(inputs: FilesList, repetitions: int = 1) -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in median function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='median', formats='tif')
	command = prostack_path + ' -o median' + ' -r ' + str(repetitions) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# finds in the binary image objects matching the template provided in the second input as the structural element
def match(inputs: FilesList) -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in match function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='match', formats='tif')
	command = prostack_path + ' -o match' + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# produces the image of the absolute value of differences between pixel values of input images
def minusabs(inputs: FilesList) -> FilesList:
	if not inputs.check_formats('tif,tif'):
		print('ERROR in minusabs function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='minusabs', formats='tif')
	command = prostack_path + ' -o minusabs' + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# combines two grayscale images into one color image
def movl2(inputs: FilesList, color_1: ColorsEnum = ColorsEnum.RED, color_2: ColorsEnum = ColorsEnum.RED) -> FilesList:
	if not inputs.check_formats('tif,tif'):
		print('ERROR in movl2 function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='movl2', formats='tif')
	command = prostack_path + ' -o movl' + ' -s ' + str(color_1.value) + ',' + str(color_2.value) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# combines three grayscale images into one color image
def movl3(inputs: FilesList, color_1: ColorsEnum = ColorsEnum.RED, color_2: ColorsEnum = ColorsEnum.RED, color_3: ColorsEnum = ColorsEnum.RED) -> FilesList:
	if not inputs.check_formats('tif,tif,tif'):
		print('ERROR in movl3 function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='movl3', formats='tif')
	command = prostack_path + ' -o movl' + ' -s ' + str(color_1.value) + ',' + str(color_2.value) + ',' + str(color_3.value) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# combines six grayscale images into one color image
def movl6(inputs: FilesList, color_1: ColorsEnum = ColorsEnum.RED, color_2: ColorsEnum = ColorsEnum.RED, color_3: ColorsEnum = ColorsEnum.RED, color_4: ColorsEnum = ColorsEnum.RED, color_5: ColorsEnum = ColorsEnum.RED, color_6: ColorsEnum = ColorsEnum.RED) -> FilesList:
	if not inputs.check_formats('tif,tif,tif,tif,tif,tif'):
		print('ERROR in movl6 function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='movl6', formats='tif')
	command = prostack_path + ' -o movl' + ' -s ' + str(color_1.value) + ',' + str(color_2.value) + ',' + str(color_3.value) + ',' + str(color_4.value) + ',' + str(color_5.value) + ',' + str(color_6.value) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# expands the dimensions of the input image
def mpad(input: File, upper_offset: int = 1, lower_offset: int = 1, left_offset: int = 1, right_offset: int = 1, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesList:
	if input.format != 'tif':
		print('ERROR in mpad function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='mpad', formats='tif')
	command = prostack_path + ' -o pad' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' -s ' + str(upper_offset) + ',' + str(lower_offset) + ',' + str(left_offset) + ',' + str(right_offset) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# multiplies each data point in multiplier image by the corresponding data point in input image and returns the product in the corresponding data point of the output image
def mul(inputs: FilesList, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesList:
	if not inputs.check_formats('tif,tif'):
		print('ERROR in mul function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='mul', formats='tif')
	command = prostack_path + ' -o mul' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# expands the dimensions of the input image
def pad(inputs: FilesList, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in pad function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='pad', formats='tif')
	command = prostack_path + ' -o pad' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# prints the values of pixels to the text file
def plot_sp(input: File, increment: int = 1, function: Plot_spFunctionEnum = Plot_spFunctionEnum.LOG) -> FilesList:
	if input.format != 'tif':
		print('ERROR in plot_sp function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='plot_sp', formats='txt')
	command = prostack_path + ' -o plot_sp' + ' -r ' + str(increment) + ' -s ' + str(function.value) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# prints the values of pixels along the line to the text file
def ppix(input: File, ac: float = 1.0, bc: float = 0.0, ar: float = 1.0, br: float = 0.0, t0: float = 0.0, tn: float = 1.0) -> FilesList:
	if input.format != 'tif':
		print('ERROR in ppix function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='ppix', formats='txt,tif')
	command = prostack_path + ' -o ppix' + ' -s ' + str(ac) + ',' + str(bc) + ',' + str(ar) + ',' + str(br) + ',' + str(t0) + ',' + str(tn) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# reads raw image and writes it in tiff format
def raw(input: File, columns: int = 1024, rows: int = 1024, bps: int = 8) -> FilesList:
	if input.format != 'tif':
		print('ERROR in raw function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='raw', formats='tif')
	command = prostack_path + ' -o raw' + ' -s ' + str(columns) + ',' + str(rows) + ',' + str(bps) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# performs morphological reconstruction of the image from the marker image
def reconstruct(inputs: FilesList, connectivity: ConnectivityEnum = ConnectivityEnum.FOUR) -> FilesList:
	if not inputs.check_formats('tif,tif'):
		print('ERROR in reconstruct function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='reconstruct', formats='tif')
	command = prostack_path + ' -o reconstruct' + ' -r ' + str(connectivity.value) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# reverses columns in the image
def revcol(input: File, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesList:
	if input.format != 'tif':
		print('ERROR in revcol function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='revcol', formats='tif')
	command = prostack_path + ' -o revcol' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# reverses rows in the image
def revrow(input: File, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesList:
	if input.format != 'tif':
		print('ERROR in revrow function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='revrow', formats='tif')
	command = prostack_path + ' -o revrow' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# produces the image of round strip that includes all blobs from the second input
def robel(inputs: FilesList) -> FilesList:
	if not inputs.check_formats('tif,tif,txt'):
		print('ERROR in robel function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='robel', formats='tif')
	command = prostack_path + ' -o robel' + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# divides the image from the second input into sectors
def rogri(inputs: FilesList, number_of_bins: int = 0, accuracy: float = 0.01) -> FilesList:
	if not inputs.check_formats('tif,tif'):
		print('ERROR in rogri function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='rogri', formats='tif')
	command = prostack_path + ' -o rogri' + ' -r ' + str(number_of_bins) + ' -p ' + str(accuracy) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# prints the pixel values from the third input to the text file in polar coordinates
def ropol(inputs: FilesList, function: Plot_spFunctionEnum = Plot_spFunctionEnum.LOG) -> FilesList:
	if not inputs.check_formats('tif,tif,tif'):
		print('ERROR in ropol function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='ropol', formats='txt')
	command = prostack_path + ' -o ropol' + ' -s ' + str(function.value) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# calculates the list of points in polar coordinates that determines the inner and outer borders of the round strip
def ropri(inputs: FilesList) -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in ropri function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='ropri', formats='txt')
	command = prostack_path + ' -o ropri' + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# computes the rotation angle using invariant moments and rotates the image
def rotate(input: File) -> FilesList:
	if input.format != 'tif':
		print('ERROR in rotate function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='rotate', formats='tif,txt')
	command = prostack_path + ' -o rotate' + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# reduces the size of the input image using pixel subsampling
def shrink(input: File, scale_from_0_to_1: float = 0.5) -> FilesList:
	if input.format != 'tif':
		print('ERROR in shrink function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='shrink', formats='tif')
	command = prostack_path + ' -o shrink' + ' -p ' + str(scale_from_0_to_1) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# calculates the given statistical estimator of pixel intensities for each blob, listed in the first input that can be generated by the blob operator
def solo(inputs: FilesList, mask_1: SoloEnum = SoloEnum.NUCLEAR, stat_1: StatisticEnum = StatisticEnum.MEAN, p_1: int = 1, mask_2: SoloEnum = SoloEnum.NUCLEAR, stat_2: StatisticEnum = StatisticEnum.MEAN, p_2: int = 1, mask_3: SoloEnum = SoloEnum.NUCLEAR, stat_3: StatisticEnum = StatisticEnum.MEAN, p_3: int = 1, mask_4: SoloEnum = SoloEnum.NUCLEAR, stat_4: StatisticEnum = StatisticEnum.MEAN, p_4: int = 1, mask_5: SoloEnum = SoloEnum.NUCLEAR, stat_5: StatisticEnum = StatisticEnum.MEAN, p_5: int = 1, output_with_8_bits: str = '-a') -> FilesList:
	if not inputs.check_formats('txt,tif,tif,tif,tif,tif'):
		print('ERROR in solo function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='solo', formats='txt')
	command = prostack_path + ' -o solo' + ' -s ' + str(mask_1.value) + ',' + str(stat_1.value) + ',' + str(p_1) + ',' + str(mask_2.value) + ',' + str(stat_2.value) + ',' + str(p_2) + ',' + str(mask_3.value) + ',' + str(stat_3.value) + ',' + str(p_3) + ',' + str(mask_4.value) + ',' + str(stat_4.value) + ',' + str(p_4) + ',' + str(mask_5.value) + ',' + str(stat_5.value) + ',' + str(p_5) + ' ' + str(output_with_8_bits) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# calculates the given statistical estimator of pixel intensities for each blob, listed in the first input that can be generated by the blob operator
def solo3(inputs: FilesList, mask_1: SoloEnum = SoloEnum.NUCLEAR, stat_1: StatisticEnum = StatisticEnum.MEAN, p_1: int = 1, mask_2: SoloEnum = SoloEnum.NUCLEAR, stat_2: StatisticEnum = StatisticEnum.MEAN, p_2: int = 1, mask_3: SoloEnum = SoloEnum.NUCLEAR, stat_3: StatisticEnum = StatisticEnum.MEAN, p_3: int = 1, output_with_8_bits: str = '-a') -> FilesList:
	if not inputs.check_formats('txt,tif,tif,tif'):
		print('ERROR in solo3 function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='solo3', formats='txt')
	command = prostack_path + ' -o solo' + ' -s ' + str(mask_1.value) + ',' + str(stat_1.value) + ',' + str(p_1) + ',' + str(mask_2.value) + ',' + str(stat_2.value) + ',' + str(p_2) + ',' + str(mask_3.value) + ',' + str(stat_3.value) + ',' + str(p_3) + ' ' + str(output_with_8_bits) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# splits the input color image into three grayscale images, one for each color channel
def splitrgb(input: File) -> FilesList:
	if input.format != 'tif':
		print('ERROR in splitrgb function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='splitrgb', formats='tif,tif,tif')
	command = prostack_path + ' -o splitrgb' + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# generates a structural element file
def strel(window_height: int = 3, window_width: int = 3, shape: ShapeEnum = ShapeEnum.DISK) -> FilesList:
	outputs = FilesList(func_name='strel', formats='txt')
	command = prostack_path + ' -o strel' + ' -s ' + str(window_height) + ',' + str(window_width) + ',' + str(shape.value) + ' ' + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# convert structural element to the image
def vstrel(input: File) -> FilesList:
	if input.format != 'txt':
		print('ERROR in vstrel function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='vstrel', formats='tif')
	command = prostack_path + ' -o vstrel' + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# filters objects in the binary image according to the shape
def sselect(inputs: FilesList, max_segment: int = 100, min_segment: int = 10, rule: SselectRuleEnum = SselectRuleEnum.ACCEPT, criterion: float = 0.1, connectivity: ConnectivityEnum = ConnectivityEnum.FOUR) -> FilesList:
	if not inputs.check_formats('tif,tif'):
		print('ERROR in sselect function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='sselect', formats='tif')
	command = prostack_path + ' -o sselect' + ' -p ' + str(criterion) + ' -s ' + str(max_segment) + ',' + str(min_segment) + ',' + str(rule.value) + ' -r ' + str(connectivity.value) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# generates a binary image by thresholding the input image
def threshold(input: File, threshold_level: float = 10.0, method: ThresholdMethodEnum = ThresholdMethodEnum.PLAIN, process: str = '-r 0') -> FilesList:
	if input.format != 'tif':
		print('ERROR in threshold function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='threshold', formats='tif,txt')
	command = prostack_path + ' -o threshold' + ' -p ' + str(threshold_level) + ' -s ' + str(method.value) + ' ' + str(process) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# generates a binary image by thresholding the input image with hysteresis
def hystthresh(input: File, low_threshold: float = 10.0, high_threshold: float = 20.0, segment: int = 10, connectivity: ConnectivityEnum = ConnectivityEnum.FOUR) -> FilesList:
	if input.format != 'tif':
		print('ERROR in hystthresh function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='hystthresh', formats='tif')
	command = prostack_path + ' -o hystthresh' + ' -s ' + str(low_threshold) + ',' + str(high_threshold) + ',' + str(segment) + ',' + str(connectivity.value) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# generates a binary image by thresholding the input image with hysteresis
def hystthresh3d(input: File, low_threshold: float = 10.0, high_threshold: float = 20.0, segment: int = 10, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX) -> FilesList:
	if input.format != 'tif':
		print('ERROR in hystthresh3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='hystthresh3d', formats='tif')
	command = prostack_path + ' -o hystthresh3d' + ' -s ' + str(low_threshold) + ',' + str(high_threshold) + ',' + str(segment) + ',' + str(connectivity.value) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# rotates image to a given angle (second input) that can be calculated by the rotate (see 8
def turn(inputs: FilesList, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in turn function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='turn', formats='tif')
	command = prostack_path + ' -o turn' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# calculates the ratio variancies of pixel values in the first input between and within two classes
def vvarbc(inputs: FilesList) -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in vvarbc function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='vvarbc', formats='txt')
	command = prostack_path + ' -o vvarbc' + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# contiguous regions of 'on' pixels surrounded by 'off' pixels (blobs) are stored in the output as the list of pixel indices
def blob(inputs: FilesList, minimal_number_of_pixels: int = 1, maximal_number_of_pixels: int = 100, maximal_number_of_blobs: int = 1000, connectivity: ConnectivityEnum = ConnectivityEnum.FOUR) -> FilesList:
	if not inputs.check_formats('tif,tif'):
		print('ERROR in blob function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='blob', formats='txt')
	command = prostack_path + ' -o blob' + ' -s ' + str(minimal_number_of_pixels) + ',' + str(maximal_number_of_pixels) + ',' + str(maximal_number_of_blobs) + ' -r ' + str(connectivity.value) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# finds regional maxima
def regmax(input: File, minimal_number_of_pixels: int = 1, maximal_number_of_pixels: int = 100, maximal_number_of_blobs: int = 1000, connectivity: ConnectivityEnum = ConnectivityEnum.FOUR) -> FilesList:
	if input.format != 'tif':
		print('ERROR in regmax function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='regmax', formats='tif')
	command = prostack_path + ' -o regmax' + ' -s ' + str(maximal_number_of_pixels) + ',' + str(minimal_number_of_pixels) + ',' + str(maximal_number_of_blobs) + ',' + str(connectivity.value) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# finds regional minima
def regmin(input: File, minimal_number_of_pixels: int = 1, maximal_number_of_pixels: int = 100, maximal_number_of_blobs: int = 1000, connectivity: ConnectivityEnum = ConnectivityEnum.FOUR) -> FilesList:
	if input.format != 'tif':
		print('ERROR in regmin function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='regmin', formats='tif')
	command = prostack_path + ' -o regmin' + ' -s ' + str(maximal_number_of_pixels) + ',' + str(minimal_number_of_pixels) + ',' + str(maximal_number_of_blobs) + ',' + str(connectivity.value) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# generates a binary image by thresholding the input image
def threshb(inputs: FilesList) -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in threshb function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='threshb', formats='tif')
	command = prostack_path + ' -o threshb' + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# sums up the image dimensions that are given by a string of four numbers which are the distances measured in pixels from the image center to its borders
def m_ar_plus(input: File, upper_offset: int = 1, lower_offset: int = 1, left_offset: int = 1, right_offset: int = 1) -> FilesList:
	if input.format != 'txt':
		print('ERROR in m_ar_plus function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='m_ar_plus', formats='txt')
	command = prostack_path + ' -o m_ar_plus' + ' -s ' + str(upper_offset) + ',' + str(lower_offset) + ',' + str(left_offset) + ',' + str(right_offset) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# multiplies the image dimensions given by a string of four numbers which are the distances measured in pixels from the image center to its borders
def m_ar_x(input: File, upper_offset: int = 1, lower_offset: int = 1, left_offset: int = 1, right_offset: int = 1) -> FilesList:
	if input.format != 'txt':
		print('ERROR in m_ar_x function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='m_ar_x', formats='txt')
	command = prostack_path + ' -o m_ar_x' + ' -s ' + str(upper_offset) + ',' + str(lower_offset) + ',' + str(left_offset) + ',' + str(right_offset) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# applies the rules to put the image of Drosophila embryo into standard orientation
def apee3d(inputs: FilesList, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in apee3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='apee3d', formats='tif')
	command = prostack_path + ' -o apee3d' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# makes a watershed transformation of an input image
def cwtsd3d(input: File, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX) -> FilesList:
	if input.format != 'tif':
		print('ERROR in cwtsd3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='cwtsd3d', formats='tif')
	command = prostack_path + ' -o cwtsd3d' + ' -r ' + str(connectivity.value) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# makes a watershed transformation of an input image
def querode(input: File, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX, iterations: int = 1) -> FilesList:
	if input.format != 'tif':
		print('ERROR in querode function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='querode', formats='tif')
	command = prostack_path + ' -o querode' + ' -r ' + str(connectivity.value) + ' -s ' + str(iterations) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# makes a watershed transformation of an input image
def quthicken(input: File, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX, iterations: int = 1) -> FilesList:
	if input.format != 'tif':
		print('ERROR in quthicken function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='quthicken', formats='tif')
	command = prostack_path + ' -o quthicken' + ' -r ' + str(connectivity.value) + ' -s ' + str(iterations) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# reduces the intensity of salt and pepper noise in an image using the Crimmins complementary hulling algorithm [1]
def despekle3d(input: File, iterations: int = 1) -> FilesList:
	if input.format != 'tif':
		print('ERROR in despekle3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='despekle3d', formats='tif')
	command = prostack_path + ' -o despekle3d' + ' -r ' + str(iterations) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# replaces the value of each pixel in the input image by the Euclidean distance from this pixel to the nearest 'off' pixel
def distance3d(input: File, window: DistanceTransformEnum = DistanceTransformEnum.THREE) -> FilesList:
	if input.format != 'tif':
		print('ERROR in distance3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='distance3d', formats='tif')
	command = prostack_path + ' -o distance3d' + ' -r ' + str(window.value) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# detects the edges of objects in the input image using the Shen-Castan Detector [5, 6]
def edge3d(input: File, a1: float = 0.76543, a2: float = 0.76543, low_threshold: float = 3, high_threshold: float = 12, window: int = 11, segment: int = 11, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX) -> FilesList:
	if input.format != 'tif':
		print('ERROR in edge3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='edge3d', formats='tif')
	command = prostack_path + ' -o edge3d' + ' -s ' + str(a1) + ',' + str(a2) + ',' + str(low_threshold) + ',' + str(high_threshold) + ',' + str(window) + ',' + str(segment) + ',' + str(connectivity.value) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# increases the size of the input image using the pixel replication
def expand3d(input: File, scale_from_1: float = 2.0) -> FilesList:
	if input.format != 'tif':
		print('ERROR in expand3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='expand3d', formats='tif')
	command = prostack_path + ' -o expand3d' + ' -p ' + str(scale_from_1) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# does successive dilations of the input image by the structural element supplied as the second input
def gdilation3d(inputs: FilesList, repetitions: int = 1) -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in gdilation3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='gdilation3d', formats='tif')
	command = prostack_path + ' -o gdilation3d' + ' -r ' + str(repetitions) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# performs morphological opening which is the erosion followed by dilation using the structural element supplied as the second input
def gopen3d(inputs: FilesList, repetitions: int = 1) -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in gopen3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='gopen3d', formats='tif')
	command = prostack_path + ' -o gopen3d' + ' -r ' + str(repetitions) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# performs morphological closing which is the dilation followed by erosion using the structural element supplied as the second input
def gclose3d(inputs: FilesList, repetitions: int = 1) -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in gclose3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='gclose3d', formats='tif')
	command = prostack_path + ' -o gclose3d' + ' -r ' + str(repetitions) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# reduces dimensions of the input image
def geometry3d(inputs: FilesList, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in geometry3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='geometry3d', formats='tif')
	command = prostack_path + ' -o geometry3d' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# does successive erosions of the input image by the structural element supplied as the second input
def gerosion3d(inputs: FilesList, repetitions: int = 1) -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in gerosion3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='gerosion3d', formats='tif')
	command = prostack_path + ' -o gerosion3d' + ' -r ' + str(repetitions) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# performs histogram equalization separately for each pixel using the neighborhood defined by the structural element from the second input
def lheq3d(inputs: FilesList, repetitions: int = 1) -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in lheq3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='lheq3d', formats='tif')
	command = prostack_path + ' -o lheq3d' + ' -r ' + str(repetitions) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# computes pixel by pixel maximum of the images in the stack
def max3d(input: File, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesList:
	if input.format != 'tif':
		print('ERROR in max3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='max3d', formats='tif')
	command = prostack_path + ' -o max3d' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# reduces the dimensions of the input image
def mcrop3d(input: File, upper_offset: int = 1, lower_offset: int = 1, left_offset: int = 1, right_offset: int = 1, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesList:
	if input.format != 'tif':
		print('ERROR in mcrop3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='mcrop3d', formats='tif')
	command = prostack_path + ' -o geometry3d' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' -s ' + str(upper_offset) + ',' + str(lower_offset) + ',' + str(left_offset) + ',' + str(right_offset) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# computes a two dimensional median filter of a structural element over the given image
def median3d(inputs: FilesList, repetitions: int = 1) -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in median3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='median3d', formats='tif')
	command = prostack_path + ' -o median3d' + ' -r ' + str(repetitions) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# expands the dimensions of the input image
def mpad3d(input: File, upper_offset: int = 1, lower_offset: int = 1, left_offset: int = 1, right_offset: int = 1, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesList:
	if input.format != 'tif':
		print('ERROR in mpad3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='mpad3d', formats='tif')
	command = prostack_path + ' -o pad3d' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' -s ' + str(upper_offset) + ',' + str(lower_offset) + ',' + str(left_offset) + ',' + str(right_offset) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# multiplies each data point in multiplier image by the corresponding data point in input image and returns the product in the corresponding data point of the output image
def mul3d(inputs: FilesList, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesList:
	if not inputs.check_formats('tif,tif'):
		print('ERROR in mul3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='mul3d', formats='tif')
	command = prostack_path + ' -o mul3d' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# expands the dimensions of the input image
def pad3d(inputs: FilesList, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in pad3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='pad3d', formats='tif')
	command = prostack_path + ' -o pad3d' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# performs morphological reconstruction of the image from the marker image
def reconstruct3d(inputs: FilesList, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX) -> FilesList:
	if not inputs.check_formats('tif,tif'):
		print('ERROR in reconstruct3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='reconstruct3d', formats='tif')
	command = prostack_path + ' -o reconstruct3d' + ' -r ' + str(connectivity.value) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# reverses columns in the image
def revcol3d(input: File, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesList:
	if input.format != 'tif':
		print('ERROR in revcol3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='revcol3d', formats='tif')
	command = prostack_path + ' -o revcol3d' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# reverses rows in the image
def revrow3d(input: File, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesList:
	if input.format != 'tif':
		print('ERROR in revrow3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='revrow3d', formats='tif')
	command = prostack_path + ' -o revrow3d' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# reduces the size of the input image using pixel subsampling
def shrink3d(input: File, scale_from_0_to_1: float = 0.5) -> FilesList:
	if input.format != 'tif':
		print('ERROR in shrink3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='shrink3d', formats='tif')
	command = prostack_path + ' -o shrink3d' + ' -p ' + str(scale_from_0_to_1) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# splits the input color image into three grayscale images, one for each color channel
def splitlsm(input: File) -> FilesList:
	if input.format != 'lsm':
		print('ERROR in splitlsm function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='splitlsm', formats='tif,tif,tif')
	command = prostack_path + ' -o splitlsm' + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# generates a structural element file
def strel3d(window_height: int = 3, window_width: int = 3, window_depth: int = 3, shape_xy: ShapeEnum = ShapeEnum.DISK, shape_yz: ShapeEnum = ShapeEnum.DISK) -> FilesList:
	outputs = FilesList(func_name='strel3d', formats='txt')
	command = prostack_path + ' -o strel3d' + ' -s ' + str(window_height) + ',' + str(window_width) + ',' + str(window_depth) + ',' + str(shape_xy.value) + ',' + str(shape_yz.value) + ' ' + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# convert structural element to the image
def vstrel3d(input: File) -> FilesList:
	if input.format != 'txt':
		print('ERROR in vstrel3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='vstrel3d', formats='tif')
	command = prostack_path + ' -o vstrel3d' + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# rotates image to a given angle (second input) that can be calculated by the rotate (see 8
def turn3d(inputs: FilesList, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in turn3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='turn3d', formats='tif')
	command = prostack_path + ' -o turn3d' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# inverts the grayscale values of all pixels in input image
def invert3d(input: File) -> FilesList:
	if input.format != 'tif':
		print('ERROR in invert3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='invert3d', formats='tif')
	command = prostack_path + ' -o invert3d' + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# fills the regions of 'off' pixels surrounded by 'on' pixels using a structural element
def chole3d(inputs: FilesList) -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in chole3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='chole3d', formats='tif')
	command = prostack_path + ' -o chole3d' + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# computes pixel by pixel maximum of the channels in the stack
def maxlsm(input: File, comma_separated_list: str = '0,1,2') -> FilesList:
	if input.format != 'lsm':
		print('ERROR in maxlsm function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='maxlsm', formats='tif')
	command = prostack_path + ' -o maxlsm' + ' -s ' + str(comma_separated_list) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# extracts one channel from the multichannel LSM image
def diglsm(input: File, channel: int = 0) -> FilesList:
	if input.format != 'lsm':
		print('ERROR in diglsm function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='diglsm', formats='tif')
	command = prostack_path + ' -o diglsm' + ' -r ' + str(channel) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# generates a binary image by thresholding the input image
def threshold3d(input: File, threshold_level: float = 10.0, method: ThresholdMethodEnum = ThresholdMethodEnum.PLAIN, process: str = '-r 0') -> FilesList:
	if input.format != 'tif':
		print('ERROR in threshold3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='threshold3d', formats='tif,txt')
	command = prostack_path + ' -o threshold3d' + ' -p ' + str(threshold_level) + ' -s ' + str(method.value) + ' ' + str(process) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# filters objects in the binary image according to the shape
def sselect3d(inputs: FilesList, max_segment: int = 100, min_segment: int = 10, rule: SselectRuleEnum = SselectRuleEnum.ACCEPT, criterion: float = 0.1, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX) -> FilesList:
	if not inputs.check_formats('tif,tif'):
		print('ERROR in sselect3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='sselect3d', formats='tif')
	command = prostack_path + ' -o sselect3d' + ' -p ' + str(criterion) + ' -s ' + str(max_segment) + ',' + str(min_segment) + ',' + str(rule.value) + ' -r Аи' + str(connectivity.value) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# converts the binary image stack to the text file
def vtxt(input: File, format: VtxtFormatEnum = VtxtFormatEnum.XYZ, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX) -> FilesList:
	if input.format != 'tif':
		print('ERROR in vtxt function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='vtxt', formats='txt')
	command = prostack_path + ' -o vtxt' + ' -s ' + str(format.value) + ' -r ' + str(connectivity.value) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# performs morphological reconstruction of the stack from the marker image
def rec3dbp(inputs: FilesList, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX, plane: int = 0) -> FilesList:
	if not inputs.check_formats('tif,tif'):
		print('ERROR in rec3dbp function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='rec3dbp', formats='tif')
	command = prostack_path + ' -o rec3dbp' + ' -r ' + str(connectivity.value) + ' -s ' + str(plane) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# extracts one plane from the stack
def getp(input: File, plane: int = 0) -> FilesList:
	if input.format != 'tif':
		print('ERROR in getp function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='getp', formats='tif')
	command = prostack_path + ' -o getp' + ' -r ' + str(plane) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# sets one plane in the stack from the second input
def setp(inputs: FilesList, plane: int = 0) -> FilesList:
	if not inputs.check_formats('tif,tif'):
		print('ERROR in setp function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='setp', formats='tif')
	command = prostack_path + ' -o setp' + ' -r ' + str(plane) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# breaks volume into two at the selected plane
def pbreak(input: File, plane: int = 0) -> FilesList:
	if input.format != 'tif':
		print('ERROR in pbreak function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='pbreak', formats='tif,tif')
	command = prostack_path + ' -o pbreak' + ' -r ' + str(plane) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# объединение плоскостей
def punite(inputs: FilesList) -> FilesList:
	if not inputs.check_formats('tif,tif'):
		print('ERROR in punite function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='punite', formats='tif')
	command = prostack_path + ' -o punite' + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# generates a structural element file
def strel3dw(window_height: int = 3, window_width: int = 3, window_depth: int = 3, window_wall: int = 3, shapexy: ShapeEnum = ShapeEnum.DISK, shapeyz: ShapeEnum = ShapeEnum.DISK) -> FilesList:
	outputs = FilesList(func_name='strel3dw', formats='txt')
	command = prostack_path + ' -o strel3dw' + ' -s ' + str(window_height) + ',' + str(window_width) + ',' + str(window_depth) + ',' + str(window_wall) + ',' + str(shapexy.value) + ',' + str(shapeyz.value) + ' ' + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# removes planes from the stack with the specified step
def restack3d(input: File, step: int = 2) -> FilesList:
	if input.format != 'tif':
		print('ERROR in restack3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='restack3d', formats='tif')
	command = prostack_path + ' -o restack3d' + ' -r ' + str(step) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# produces triangulated surface
def surf3d(input: File, scale_column: float = 1, scale_row: float = 1, scale_plane: float = 1, maximal_penalty_of_edge_removal: float = 1000, minimal_angle: float = 1, format: Surf3dFormatEnum = Surf3dFormatEnum.VTK) -> FilesList:
	if input.format != 'tif':
		print('ERROR in surf3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='surf3d', formats='txt')
	command = prostack_path + ' -o surf3d' + ' -s ' + str(scale_column) + ',' + str(scale_row) + ',' + str(scale_plane) + ',' + str(maximal_penalty_of_edge_removal) + ',' + str(minimal_angle) + ',' + str(format.value) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# outputs the description of the shape
def shape(input: File) -> FilesList:
	if input.format != 'tif':
		print('ERROR in shape function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='shape', formats='txt')
	command = prostack_path + ' -o shape' + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# outputs the description of the shape
def shape3d(input: File, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX) -> FilesList:
	if input.format != 'tif':
		print('ERROR in shape3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='shape3d', formats='txt')
	command = prostack_path + ' -o shape3d' + ' -r ' + str(connectivity.value) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# averages two images pixel by pixel
def vavg(inputs: FilesList, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesList:
	if not inputs.check_formats('tif,tif'):
		print('ERROR in vavg function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='vavg', formats='tif')
	command = prostack_path + ' -o vavg' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# computes pixel by pixel maximum of two input images
def vmax(inputs: FilesList, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesList:
	if not inputs.check_formats('tif,tif'):
		print('ERROR in vmax function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='vmax', formats='tif')
	command = prostack_path + ' -o vmax' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# combines three grayscale images into one color image
def vrgb(inputs: FilesList) -> FilesList:
	if not inputs.check_formats('tif,tif,tif'):
		print('ERROR in vrgb function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='vrgb', formats='tif')
	command = prostack_path + ' -o vrgb' + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# produces the image of the absolute value of differences between pixel values of input images
def vmabs(inputs: FilesList) -> FilesList:
	if not inputs.check_formats('tif,tif'):
		print('ERROR in vmabs function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='vmabs', formats='tif')
	command = prostack_path + ' -o vmabs' + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# rotates the stack around the vertical axis
def lv3d(input: File) -> FilesList:
	if input.format != 'tif':
		print('ERROR in lv3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='lv3d', formats='tif')
	command = prostack_path + ' -o lv3d' + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# rotates the stack around the vertical axis in the direction opposite to that used in the lv3d (see 8
def rv3d(input: File) -> FilesList:
	if input.format != 'tif':
		print('ERROR in rv3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='rv3d', formats='tif')
	command = prostack_path + ' -o rv3d' + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# rotates the stack around the horizontal axis
def tv3d(input: File) -> FilesList:
	if input.format != 'tif':
		print('ERROR in tv3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='tv3d', formats='tif')
	command = prostack_path + ' -o tv3d' + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# scales the stack in z direction
def zscale3d(input: File, scale_from_1: float = 2.0) -> FilesList:
	if input.format != 'tif':
		print('ERROR in zscale3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='zscale3d', formats='tif')
	command = prostack_path + ' -o zscale3d' + ' -p ' + str(scale_from_1) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# adds the quantitative data from another channel to the initialized storage
def qu3d(inputs: FilesList, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX, tag: str = 'channel1') -> FilesList:
	if not inputs.check_formats('tif,tif,txt'):
		print('ERROR in qu3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='qu3d', formats='txt')
	command = prostack_path + ' -o qu3d' + ' -r ' + str(connectivity.value) + ' -s ' + str(tag) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# adds the number of blob in the 2nd channel as the tag to the quantitative data for the 1st channel to the initialized storage
def quremask(inputs: FilesList, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX, tag: str = 'channel1') -> FilesList:
	if not inputs.check_formats('tif,tif,txt'):
		print('ERROR in quremask function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='quremask', formats='txt')
	command = prostack_path + ' -o quremask' + ' -r ' + str(connectivity.value) + ' -s ' + str(tag) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# adds the number of blob in sorted list
def quresort(inputs: FilesList, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX, tag: str = 'channel1', index: int = 0, reftag: str = 'refch', newtag: str = 'newch', ascending: str = '0') -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in quresort function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='quresort', formats='txt,tif')
	command = prostack_path + ' -o quresort' + ' -r ' + str(connectivity.value) + ' -s ' + str(tag) + ',' + str(index) + ',' + str(reftag) + ',' + str(newtag) + ',' + str(ascending) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# initializes the storage and adds the quantitative data from one channel
def qu3dinit(inputs: FilesList, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX, tag: str = 'channel1') -> FilesList:
	if not inputs.check_formats('tif,tif'):
		print('ERROR in qu3dinit function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='qu3dinit', formats='txt')
	command = prostack_path + ' -o qu3d' + ' -r ' + str(connectivity.value) + ' -s ' + str(tag) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# converts the quantitative data to CSV format
def qu3d2csv(input: File) -> FilesList:
	if input.format != 'txt':
		print('ERROR in qu3d2csv function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='qu3d2csv', formats='csv')
	command = prostack_path + ' -o qu3d2csv' + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# performs deconvolution of the input image using Richardson-Lucy algorithm
def decsup(inputs: FilesList, max_num_of_iterations: int = 100, criterion: float = 0.01, lmbd: float = 0.001, psf_type: PSFTypeEnum = PSFTypeEnum.BESSEL) -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in decsup function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='decsup', formats='tif')
	command = prostack_path + ' -o decsup' + ' -s ' + str(max_num_of_iterations) + ',' + str(criterion) + ',' + str(lmbd) + ',' + str(psf_type.value) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# performs deconvolution of the input image using Richardson-Lucy algorithm
def decsup_i(input: File, max_num_of_iterations: int = 100, criterion: float = 0.01, lmbd: float = 0.001, psf_type: PSFTypeEnum = PSFTypeEnum.BESSEL, psf_parameter: float = 1.07, window: int = -1) -> FilesList:
	if input.format != 'tif':
		print('ERROR in decsup_i function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='decsup_i', formats='tif')
	command = prostack_path + ' -o decsup' + ' -s ' + str(max_num_of_iterations) + ',' + str(criterion) + ',' + str(lmbd) + ',' + str(psf_type.value) + ',' + str(psf_parameter) + ',' + str(window) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# performs a blind deconvolution of the input image
def decbsup(inputs: FilesList, max_num_of_iterations: int = 100, max_blind_iter: int = 100, criterion: float = 0.01, lmbd: float = 0.001, psf_type: PSFTypeEnum = PSFTypeEnum.BESSEL) -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in decbsup function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='decbsup', formats='tif,txt')
	command = prostack_path + ' -o decbsup' + ' -s ' + str(max_num_of_iterations) + ',' + str(max_blind_iter) + ',' + str(criterion) + ',' + str(lmbd) + ',' + str(psf_type.value) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# performs a blind deconvolution of the input image
def decbsup_i(input: File, max_num_of_iterations: int = 100, max_blind_iter: int = 100, criterion: float = 0.01, lmbd: float = 0.001, psf_type: PSFTypeEnum = PSFTypeEnum.BESSEL, psf_parameter: float = 1.07, window: int = -1) -> FilesList:
	if input.format != 'tif':
		print('ERROR in decbsup_i function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='decbsup_i', formats='tif,txt')
	command = prostack_path + ' -o decbsup' + ' -s ' + str(max_num_of_iterations) + ',' + str(max_blind_iter) + ',' + str(criterion) + ',' + str(lmbd) + ',' + str(psf_type.value) + ',' + str(psf_parameter) + ',' + str(window) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# performs deconvolution of the input image using Wiener filter
def decwiener(inputs: FilesList, lmbd: float = 0.001, psf_type: PSFTypeEnum = PSFTypeEnum.BESSEL, gamma: float = 1.0, alpha: float = 1.0) -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in decwiener function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='decwiener', formats='tif')
	command = prostack_path + ' -o decwiener' + ' -s ' + str(lmbd) + ',' + str(psf_type.value) + ',' + str(gamma) + ',' + str(alpha) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# performs deconvolution of the input image using Wiener filter
def decwiener_i(input: File, lmbd: float = 0.01, psf_type: PSFTypeEnum = PSFTypeEnum.BESSEL, psf_parameter: float = 1.07, gamma: float = 1.0, alpha: float = 1.0, window: int = -1) -> FilesList:
	if input.format != 'tif':
		print('ERROR in decwiener_i function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='decwiener_i', formats='tif')
	command = prostack_path + ' -o decwiener' + ' -s ' + str(lmbd) + ',' + str(psf_type.value) + ',' + str(psf_parameter) + ',' + str(gamma) + ',' + str(alpha) + ',' + str(window) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# performs deconvolution of the input image using Tikhonov-Miller algorithm
def dectm(inputs: FilesList, lmbd: float = 0.001, psf_type: PSFTypeEnum = PSFTypeEnum.BESSEL, gamma: float = 1.0) -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in dectm function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='dectm', formats='tif')
	command = prostack_path + ' -o dectm' + ' -s ' + str(lmbd) + ',' + str(psf_type.value) + ',' + str(gamma) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# performs deconvolution of the input image using Tikhonov-Miller algorithm
def dectm_i(input: File, lmbd: float = 0.01, psf_type: PSFTypeEnum = PSFTypeEnum.BESSEL, psf_parameter: float = 1.07, gamma: float = 1.0, window: int = -1) -> FilesList:
	if input.format != 'tif':
		print('ERROR in dectm_i function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='dectm_i', formats='tif')
	command = prostack_path + ' -o dectm' + ' -s ' + str(lmbd) + ',' + str(psf_type.value) + ',' + str(psf_parameter) + ',' + str(gamma) + ',' + str(window) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# performs deconvolution of the input image using inverse filter
def decinv(inputs: FilesList, lmbd: float = 0.001, psf_type: PSFTypeEnum = PSFTypeEnum.BESSEL, gamma: float = 1.0) -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in decinv function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='decinv', formats='tif')
	command = prostack_path + ' -o decinv' + ' -s ' + str(lmbd) + ',' + str(psf_type.value) + ',' + str(gamma) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# performs deconvolution of the input image using inverse filter
def decinv_i(input: File, lmbd: float = 0.01, psf_type: PSFTypeEnum = PSFTypeEnum.BESSEL, psf_parameter: float = 1.07, gamma: float = 1.0, window: int = -1) -> FilesList:
	if input.format != 'tif':
		print('ERROR in decinv_i function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='decinv_i', formats='tif')
	command = prostack_path + ' -o decinv' + ' -s ' + str(lmbd) + ',' + str(psf_type.value) + ',' + str(psf_parameter) + ',' + str(gamma) + ',' + str(window) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# calculates the ratio of variancies of pixel values in the image between and within two classes
def vvarbc3d(input: File, output_section: str = 'Statistics', class_1_section: str = 'Shape:1', class_1_data: str = 'channel1', class_2_section: str = 'Shape:2', class_2_data: str = 'channel2') -> FilesList:
	if input.format != 'txt':
		print('ERROR in vvarbc3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='vvarbc3d', formats='txt')
	command = prostack_path + ' -o vvarbc3d' + ' -s ' + str(output_section) + ',' + str(class_1_section) + ',' + str(class_1_data) + ',' + str(class_2_section) + ',' + str(class_2_data) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# removes background signal form the image
def vrmbg(inputs: FilesList, bgr_mean_coeff: float = 1.0, bgr_section: str = 'Shape:0', bgr_stdev_coeff: float = 3.0, bgr_data: str = 'channel1') -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in vrmbg function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='vrmbg', formats='tif')
	command = prostack_path + ' -o vrmbg' + ' -s ' + str(bgr_mean_coeff) + ',' + str(bgr_section) + ',' + str(bgr_stdev_coeff) + ',' + str(bgr_data) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# removes background signal form the image
def vrmbg_1(input: File, bgr_mean_coeff: float = 1.0, bgr_mean: float = 8.0, bgr_stdev_coeff: float = 3.0, bgr_stdev: float = 7.0) -> FilesList:
	if input.format != 'tif':
		print('ERROR in vrmbg_1 function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='vrmbg_1', formats='tif')
	command = prostack_path + ' -o vrmbg' + ' -s ' + str(bgr_mean_coeff) + ',' + str(bgr_mean) + ',' + str(bgr_stdev_coeff) + ',' + str(bgr_stdev) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# produces the image of the cartesian grid
def grid(input: File, number_of_bins: int = 0) -> FilesList:
	if input.format != 'tif':
		print('ERROR in grid function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='grid', formats='tif')
	command = prostack_path + ' -o grid' + ' -r ' + str(number_of_bins) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# produces the image of the grid
def grid3d_i(input: File, type: Grid3d_iTypeEnum = Grid3d_iTypeEnum.CARTESIAN, cell_height_: float = 1, cell_width_: float = 1, cell_depth_: float = 1, offset_: float = 0.5, criterion: float = 0.01, x_center: float = 100.0, y_center: float = 100.0, z_center: float = 100.0) -> FilesList:
	if input.format != 'tif':
		print('ERROR in grid3d_i function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='grid3d_i', formats='tif')
	command = prostack_path + ' -o grid3d' + ' -s ' + str(type.value) + ',' + str(cell_height_) + ',' + str(cell_width_) + ',' + str(cell_depth_) + ',' + str(offset_) + ',' + str(criterion) + ',' + str(x_center) + ',' + str(y_center) + ',' + str(z_center) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# produces the image of the grid
def grid3d(inputs: FilesList, type: Grid3d_iTypeEnum = Grid3d_iTypeEnum.CARTESIAN, cell_height_: float = 1, cell_width_: float = 1, cell_depth_: float = 1, offset_: float = 0.5, criterion: float = 0.01, shape_section: str = 'Shape:0') -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in grid3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='grid3d', formats='tif')
	command = prostack_path + ' -o grid3d' + ' -s ' + str(type.value) + ',' + str(cell_height_) + ',' + str(cell_width_) + ',' + str(cell_depth_) + ',' + str(offset_) + ',' + str(criterion) + ',' + str(shape_section) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# filters the list of the objects and transforms their coordinates
def qu3dtrans(inputs: FilesList, shape_section: str = 'Shape:0', center: str = '0', percent: str = '0', min_volume: float = 20.0, max_volume: float = 350.0) -> FilesList:
	if not inputs.check_formats('txt,txt'):
		print('ERROR in qu3dtrans function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='qu3dtrans', formats='txt')
	command = prostack_path + ' -o qu3dtrans' + ' -s ' + str(shape_section) + ',' + str(center) + ',' + str(percent) + ',' + str(min_volume) + ',' + str(max_volume) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# produces triangulated surface
def surf3dfull(input: File, scale_column: float = 1, scale_row: float = 1, scale_plane: float = 1, maximal_penalty_of_edge_removal: float = 1000, minimal_angle: float = 1, format: Surf3dFormatEnum = Surf3dFormatEnum.VTK, step_for_y: float = 1, step_for_x: float = 1, step_for_z: float = 1, function: Surf3dfullFunctionEnum = Surf3dfullFunctionEnum.CARTESIAN) -> FilesList:
	if input.format != 'tif':
		print('ERROR in surf3dfull function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='surf3dfull', formats='txt')
	command = prostack_path + ' -o surf3dfull' + ' -s ' + str(scale_column) + ',' + str(scale_row) + ',' + str(scale_plane) + ',' + str(maximal_penalty_of_edge_removal) + ',' + str(minimal_angle) + ',' + str(format.value) + ',' + str(step_for_y) + ',' + str(step_for_x) + ',' + str(step_for_z) + ',' + str(function.value) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# draws triangulated surface
def surf2vol(input: File) -> FilesList:
	if input.format != 'txt':
		print('ERROR in surf2vol function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='surf2vol', formats='tif')
	command = prostack_path + ' -o surf2vol' + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# converts an image into a stack using the distance map to determine the z coordinate
def pump3d(input: File) -> FilesList:
	if input.format != 'tif':
		print('ERROR in pump3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='pump3d', formats='tif')
	command = prostack_path + ' -o pump3d' + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# converts an image into a stack using the distance map to determine the z coordinate
def pump3d_data(inputs: FilesList) -> FilesList:
	if not inputs.check_formats('tif,tif'):
		print('ERROR in pump3d_data function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='pump3d_data', formats='tif')
	command = prostack_path + ' -o pump3d' + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# visualizes the distance image supplied as the first input
def mslice3d(inputs: FilesList, cell_step_: float = 1, direction: int = 2, shape_section: str = 'Shape:0') -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in mslice3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='mslice3d', formats='tif')
	command = prostack_path + ' -o mslice3d' + ' -s ' + str(shape_section) + ',' + str(cell_step_) + ',' + str(direction) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# finds control points for registration using the distance image
def mslicegcp3d(inputs: FilesList, cell_step_: float = 1, direction: int = 2, slice_direction: int = 2, shape_section: str = 'Shape:0', cell_height_: float = 1, cell_width_: float = 1, cell_depth_: float = 1) -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in mslicegcp3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='mslicegcp3d', formats='tif')
	command = prostack_path + ' -o mslicegcp3d' + ' -s ' + str(shape_section) + ',' + str(cell_step_) + ',' + str(direction) + ',' + str(slice_direction) + ',' + str(cell_height_) + ',' + str(cell_width_) + ',' + str(cell_depth_) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# registers two images using control points and moving least squares method
def mlsreg(inputs: FilesList, alpha: float = 1, type: MlsregTypeEnum = MlsregTypeEnum.AFFINE) -> FilesList:
	if not inputs.check_formats('tif,tif,tif'):
		print('ERROR in mlsreg function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='mlsreg', formats='tif')
	command = prostack_path + ' -o mlsreg' + ' -s ' + str(type.value) + ',' + str(alpha) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# collapses the islands of bright pixels in the binary image to exactly one pixel
def qumark3d(input: File, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX) -> FilesList:
	if input.format != 'tif':
		print('ERROR in qumark3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='qumark3d', formats='tif')
	command = prostack_path + ' -o qumark3d' + ' -r ' + str(connectivity.value) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# paints the binary mask with the intensities from quantitative data
def qumap3d(inputs: FilesList, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX, channel: str = 'channel1', index: int = 1) -> FilesList:
	if not inputs.check_formats('tif,txt'):
		print('ERROR in qumap3d function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='qumap3d', formats='tif')
	command = prostack_path + ' -o qumap3d' + ' -r ' + str(connectivity.value) + ' -s ' + str(channel) + ',' + str(index) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# labels each object in the registered mask with its index in the unregistered mask
def qurelabel(inputs: FilesList, alpha: float = 1, type: MlsregTypeEnum = MlsregTypeEnum.AFFINE, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX) -> FilesList:
	if not inputs.check_formats('tif,txt,tif,tif'):
		print('ERROR in qurelabel function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='qurelabel', formats='txt')
	command = prostack_path + ' -o qurelabel' + ' -s ' + str(type.value) + ',' + str(alpha) + ' -r ' + str(connectivity.value) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# computes a linear combination of two images pixel by pixel
def vaff(inputs: FilesList, coeff_1: float = 1.0, coeff_2: float = 1.0, coeff_3: float = 0.0) -> FilesList:
	if not inputs.check_formats('tif,tif'):
		print('ERROR in vaff function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='vaff', formats='tif')
	command = prostack_path + ' -o vaff' + ' -s ' + str(coeff_1) + ',' + str(coeff_2) + ',' + str(coeff_3) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# adds the quantitative data from another channel to the initialized storage
def quvu(inputs: FilesList, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX, tag: str = 'channel1', cycles: int = 3, vertlim: int = 10, alpha: float = 2.0) -> FilesList:
	if not inputs.check_formats('tif,tif,txt'):
		print('ERROR in quvu function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='quvu', formats='txt')
	command = prostack_path + ' -o quvu' + ' -r ' + str(connectivity.value) + ' -s ' + str(tag) + ',' + str(vertlim) + ',' + str(alpha) + ' -p ' + str(cycles) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# combines six grayscale images into one color image
def movl8(inputs: FilesList, color_1: ColorsEnum = ColorsEnum.RED, color_2: ColorsEnum = ColorsEnum.RED, color_3: ColorsEnum = ColorsEnum.RED, color_4: ColorsEnum = ColorsEnum.RED, color_5: ColorsEnum = ColorsEnum.RED, color_6: ColorsEnum = ColorsEnum.RED, color_7: ColorsEnum = ColorsEnum.RED, color_8: ColorsEnum = ColorsEnum.RED) -> FilesList:
	if not inputs.check_formats('tif,tif,tif,tif,tif,tif,tif,tif'):
		print('ERROR in movl8 function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='movl8', formats='tif')
	command = prostack_path + ' -o movl' + ' -s ' + str(color_1.value) + ',' + str(color_2.value) + ',' + str(color_3.value) + ',' + str(color_4.value) + ',' + str(color_5.value) + ',' + str(color_6.value) + ',' + str(color_7.value) + ',' + str(color_8.value) + ' ' + inputs.get_command() + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# 
def convert(input: File, channel: str = 'R') -> FilesList:
	if input.format != 'tif':
		print('ERROR in convert function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='convert', formats='tif')
	command = image_magick_path + ' ' + 'convert' + ' -depth 8 -channel ' + str(channel) + ' -separate' + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# this method subtracts pixels from the original image to reduce the shapes into skeletons
def thinning(input: File, iterations: int = -1) -> FilesList:
	if input.format != 'tif':
		print('ERROR in thinning function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='thinning', formats='tif')
	command = image_magick_path + ' ' + 'convert' + ' -depth 8 -morphology Thinning:' + str(iterations) + ' Diagonals -morphology Thinning Corners' + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# this method correlates image with gaussian
def correlate(input: File, radius: int = 0, sigma: float = 1.0) -> FilesList:
	if input.format != 'tif':
		print('ERROR in correlate function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='correlate', formats='tif')
	command = image_magick_path + ' ' + 'convert' + ' -define convolve:scale="1^" -morphology Correlate Gaussian:' + str(radius) + 'x' + str(sigma) + ' -depth 8' + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# convolution with Laplacian of gaussians
def LoG(input: File, radius: int = 0, sigma: float = 1.0) -> FilesList:
	if input.format != 'tif':
		print('ERROR in LoG function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='LoG', formats='tif')
	command = image_magick_path + ' ' + 'convert' + ' -define -morphology Convolve LoG:' + str(radius) + ',' + str(sigma) + ' -depth 8' + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# convolution with difference of gaussians
def DoG(input: File, radius: int = 0, sigma_1: float = 1.0, sigma_2: float = 1.5) -> FilesList:
	if input.format != 'tif':
		print('ERROR in DoG function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='DoG', formats='tif')
	command = image_magick_path + ' ' + 'convert' + ' -define -morphology Convolve DoG:' + str(radius) + ',' + str(sigma_1) + ',' + str(sigma_2) + ' -depth 8' + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# implements the Canny algorithm for edge detection
def imcanny(input: File, radius: float = 0, sigma: float = 1, low_frac: float = 0.1, upper_frac: str = '0.3') -> FilesList:
	if input.format != 'tif':
		print('ERROR in imcanny function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='imcanny', formats='tif')
	command = image_magick_path + ' ' + 'convert -canny' + ' ' + str(radius) + 'x' + str(sigma) + '+' + str(low_frac) + '+' + str(upper_frac) + ' -depth 8' + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# пороговый фильтр
def lat(input: File, radius: int = 10) -> FilesList:
	if input.format != 'tif':
		print('ERROR in lat function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='lat', formats='tif')
	command = image_magick_path + ' ' + 'convert -lat' + ' ' + str(radius) + ' -depth 8' + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


# convolution with Laplacian kernel
def laplacian(input: File, type: int = 0, scale: str = '-1!', bias: float = 0.5) -> FilesList:
	if input.format != 'tif':
		print('ERROR in laplacian function: incorrect type of input files')
		return FilesList()
	outputs = FilesList(func_name='laplacian', formats='tif')
	command = image_magick_path + ' ' + 'convert' + ' -define convolve:scale="' + str(scale) + '" -bias ' + str(bias) + ' -morphology Convolve Laplacian:' + str(type) + ' ' + input.file_path + ' ' + outputs.get_command()
	os.system(command)
	return outputs


