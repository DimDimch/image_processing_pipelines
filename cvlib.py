import os
from files_manager import FilesManager
from cvlib_enums import *

prostack_path = 'prostak.exe'


# generates the rules to put the image of Drosophila embryo into standard orientation
def align(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='align', formats='txt')
	output_command = outputs.get_command('txt', need_comma=True)
	os.system(prostack_path + ' -o align' + ' ' + input_command + ' ' + output_command)
	return outputs


# diffusion algorithms remove noise from an image by modifying the image via a partial differential equation (PDE)
def andif(inputs: FilesManager, iterations: int = 3, time_step: float = 0.9, threshold: float = 0.9, function_type: AndifFunction_typeEnum = AndifFunction_typeEnum.exp) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='andif', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o andif' + ' -s ' + str(iterations) + ',' + str(time_step) + ',' + str(threshold) + ',' + str(function_type.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# applies the rules to put the image of Drosophila embryo into standard orientation
def apee(inputs: FilesManager, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='apee', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o apee' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + input_command + ' ' + output_command)
	return outputs


# checks the rules generated by align (see 8
def apsc(inputs: FilesManager, direction: APEnum = APEnum.A) -> FilesManager:
	input_command = inputs.get_command('txt,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='apsc', formats='txt')
	output_command = outputs.get_command('txt', need_comma=True)
	os.system(prostack_path + ' -o apsc' + ' -s ' + str(direction.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# subtracts the image dimensions that are given as a string of four numbers which are distances measured in pixels from the image center to its borders
def ar_minus(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('txt,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='ar_minus', formats='txt')
	output_command = outputs.get_command('txt', need_comma=True)
	os.system(prostack_path + ' -o ar_minus' + ' ' + input_command + ' ' + output_command)
	return outputs


# sums up the image dimensions that are given by a string of four numbers which are the distances measured in pixels from the image center to its borders
def ar_plus(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('txt,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='ar_plus', formats='txt')
	output_command = outputs.get_command('txt', need_comma=True)
	os.system(prostack_path + ' -o ar_plus' + ' ' + input_command + ' ' + output_command)
	return outputs


# multiplies by a constant the image dimensions given by a string of four numbers which are the distances measured in pixels from the image center to its borders
def ar_x(inputs: FilesManager, value: float = 1) -> FilesManager:
	input_command = inputs.get_command('txt', need_comma=False)
	outputs = FilesManager()
	outputs.create_files(func_name='ar_x', formats='txt')
	output_command = outputs.get_command('txt', need_comma=False)
	os.system(prostack_path + ' -o ar_x' + ' -p ' + str(value) + ' ' + input_command + ' ' + output_command)
	return outputs


# averages three images pixel by pixel
def avg(inputs: FilesManager, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesManager:
	input_command = inputs.get_command('tif,tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='avg', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o avg' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + input_command + ' ' + output_command)
	return outputs


# averages two images pixel by pixel
def avg2(inputs: FilesManager, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesManager:
	input_command = inputs.get_command('tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='avg2', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o avg' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + input_command + ' ' + output_command)
	return outputs


# converts the coordinates of centroids of blobs to polar coordinates
def blo2pol(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='blo2pol', formats='txt')
	output_command = outputs.get_command('txt', need_comma=True)
	os.system(prostack_path + ' -o blo2pol' + ' ' + input_command + ' ' + output_command)
	return outputs


# restores an image of blobs from the list stored in the input file
def bolb(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='bolb', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o bolb' + ' ' + input_command + ' ' + output_command)
	return outputs


# restores an image of the selected blob from the list stored in the input file
def bolin(inputs: FilesManager, index: int = 0) -> FilesManager:
	input_command = inputs.get_command('txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='bolin', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o bolin' + ' -r ' + str(index) + ' ' + input_command + ' ' + output_command)
	return outputs


# calculates the average intensity in the left and right parts of the image
def chemar(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='chemar', formats='txt')
	output_command = outputs.get_command('txt', need_comma=True)
	os.system(prostack_path + ' -o chemar' + ' ' + input_command + ' ' + output_command)
	return outputs


# fills the regions of 'off' pixels surrounded by 'on' pixels using a structural element
def chole(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='chole', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o chole' + ' ' + input_command + ' ' + output_command)
	return outputs


# reduces the dimensions of the input image to the minimal rectangular area required to cover all 'on' pixels
def crop(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='crop', formats='tif,txt')
	output_command = outputs.get_command('tif,txt', need_comma=True)
	os.system(prostack_path + ' -o crop' + ' ' + input_command + ' ' + output_command)
	return outputs


# makes a watershed transformation of an input image
def cwtsd(inputs: FilesManager, connectivity: ConnectivityEnum = ConnectivityEnum.FOUR) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='cwtsd', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o cwtsd' + ' -r ' + str(connectivity.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# reduces the intensity of salt and pepper noise in an image using the Crimmins complementary hulling algorithm [1]
def despekle(inputs: FilesManager, iterations: int = 1) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='despekle', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o despekle' + ' -r ' + str(iterations) + ' ' + input_command + ' ' + output_command)
	return outputs


# replaces the value of each pixel in the input image by the Euclidean distance from this pixel to the nearest 'off' pixel
def distance(inputs: FilesManager, window: DistanceTransformEnum = DistanceTransformEnum.THREE) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='distance', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o distance' + ' -r ' + str(window.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# detects the edges of objects in the input image using the Shen-Castan Detector [5, 6]
def edge(inputs: FilesManager, a1: float = 0.76543, a2: float = 0.76543, low_threshold: float = 3, high_threshold: float = 12, window: int = 11, segment: int = 11, connectivity: ConnectivityEnum = ConnectivityEnum.FOUR) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='edge', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o edge' + ' -s ' + str(a1) + ',' + str(a2) + ',' + str(low_threshold) + ',' + str(high_threshold) + ',' + str(window) + ',' + str(segment) + ',' + str(connectivity.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# increases the size of the input image using the pixel replication
def expand(inputs: FilesManager, scale_from_1: float = 2.0) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='expand', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o expand' + ' -p ' + str(scale_from_1) + ' ' + input_command + ' ' + output_command)
	return outputs


# fills the regions of 'off' pixels surrounded by 'on' pixels
def fill(inputs: FilesManager, connectivity: ConnectivityEnum = ConnectivityEnum.FOUR) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='fill', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o fill' + ' -r ' + str(connectivity.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# does successive dilations of the input image by the structural element supplied as the second input
def gdilation(inputs: FilesManager, repetitions: int = 1) -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='gdilation', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o gdilation' + ' -r ' + str(repetitions) + ' ' + input_command + ' ' + output_command)
	return outputs


# performs morphological opening which is the erosion followed by dilation using the structural element supplied as the second input
def gopen(inputs: FilesManager, repetitions: int = 1) -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='gopen', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o gopen' + ' -r ' + str(repetitions) + ' ' + input_command + ' ' + output_command)
	return outputs


# performs morphological closing which is the dilation followed by erosion using the structural element supplied as the second input
def gclose(inputs: FilesManager, repetitions: int = 1) -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='gclose', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o gclose' + ' -r ' + str(repetitions) + ' ' + input_command + ' ' + output_command)
	return outputs


# reduces dimensions of the input image
def geometry(inputs: FilesManager, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='geometry', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o geometry' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + input_command + ' ' + output_command)
	return outputs


# does successive erosions of the input image by the structural element supplied as the second input
def gerosion(inputs: FilesManager, repetitions: int = 1) -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='gerosion', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o gerosion' + ' -r ' + str(repetitions) + ' ' + input_command + ' ' + output_command)
	return outputs


# calculates the magnitude of the gradient
def gmag(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='gmag', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o gmag' + ' ' + input_command + ' ' + output_command)
	return outputs


# prints dimensions of the image as a string of four numbers representing the distance in pixels from the image center to the borders
def halfsizes(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='halfsizes', formats='txt')
	output_command = outputs.get_command('txt', need_comma=True)
	os.system(prostack_path + ' -o halfsizes' + ' ' + input_command + ' ' + output_command)
	return outputs


# performs the histogram equalization taking into account only those pixels that are 'on' in the mask that comes from the second input
def heqm(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='heqm', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o heq' + ' ' + input_command + ' ' + output_command)
	return outputs


# equalizes the histogram of the image
def heq(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='heq', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o heq' + ' ' + input_command + ' ' + output_command)
	return outputs


# normalizes the histogram of the image
def hno(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='hno', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o hno' + ' ' + input_command + ' ' + output_command)
	return outputs


# combines grayscale images of three color channels (Red, Green and Blue) to the one grayscale image in which each pixel equals the product of Hue and Saturation values in this pixel
def hues(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif,tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='hues', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o hues' + ' ' + input_command + ' ' + output_command)
	return outputs


# inverts the grayscale values of all pixels in input image
def invert(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='invert', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o invert' + ' ' + input_command + ' ' + output_command)
	return outputs


# those pixels that have the given intensity in the input image have the maximal intensity in the output image
def lev(inputs: FilesManager, index: int = 0) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='lev', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o lev' + ' -r ' + str(index) + ' ' + input_command + ' ' + output_command)
	return outputs


# performs histogram equalization separately for each pixel using the neighborhood defined by the structural element from the second input
def lheq(inputs: FilesManager, repetitions: int = 1) -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='lheq', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o lheq' + ' -r ' + str(repetitions) + ' ' + input_command + ' ' + output_command)
	return outputs


# estimates background for each pixel using the neighborhood defined by the structural element from the second input
def lhbg(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='lhbg', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o lhbg' + ' ' + input_command + ' ' + output_command)
	return outputs


# masks the first input image by the second one
def mask(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='mask', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o mask' + ' ' + input_command + ' ' + output_command)
	return outputs


# computes pixel by pixel maximum of three input images
def max(inputs: FilesManager, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesManager:
	input_command = inputs.get_command('tif,tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='max', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o max' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + input_command + ' ' + output_command)
	return outputs


# computes pixel by pixel maximum of two input images
def max2(inputs: FilesManager, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesManager:
	input_command = inputs.get_command('tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='max2', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o max' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + input_command + ' ' + output_command)
	return outputs


# reduces the dimensions of the input image
def mcrop(inputs: FilesManager, upper_offset: int = 1, lower_offset: int = 1, left_offset: int = 1, right_offset: int = 1, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='mcrop', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o geometry' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' -s ' + str(upper_offset) + ',' + str(lower_offset) + ',' + str(left_offset) + ',' + str(right_offset) + ' ' + input_command + ' ' + output_command)
	return outputs


# computes a two dimensional median filter of a structural element over the given image
def median(inputs: FilesManager, repetitions: int = 1) -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='median', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o median' + ' -r ' + str(repetitions) + ' ' + input_command + ' ' + output_command)
	return outputs


# finds in the binary image objects matching the template provided in the second input as the structural element
def match(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='match', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o match' + ' ' + input_command + ' ' + output_command)
	return outputs


# produces the image of the absolute value of differences between pixel values of input images
def minusabs(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='minusabs', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o minusabs' + ' ' + input_command + ' ' + output_command)
	return outputs


# combines two grayscale images into one color image
def movl2(inputs: FilesManager, color_1: ColorsEnum = ColorsEnum.RED, color_2: ColorsEnum = ColorsEnum.RED) -> FilesManager:
	input_command = inputs.get_command('tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='movl2', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o movl' + ' -s ' + str(color_1.value) + ',' + str(color_2.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# combines three grayscale images into one color image
def movl3(inputs: FilesManager, color_1: ColorsEnum = ColorsEnum.RED, color_2: ColorsEnum = ColorsEnum.RED, color_3: ColorsEnum = ColorsEnum.RED) -> FilesManager:
	input_command = inputs.get_command('tif,tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='movl3', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o movl' + ' -s ' + str(color_1.value) + ',' + str(color_2.value) + ',' + str(color_3.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# combines six grayscale images into one color image
def movl6(inputs: FilesManager, color_1: ColorsEnum = ColorsEnum.RED, color_2: ColorsEnum = ColorsEnum.RED, color_3: ColorsEnum = ColorsEnum.RED, color_4: ColorsEnum = ColorsEnum.RED, color_5: ColorsEnum = ColorsEnum.RED, color_6: ColorsEnum = ColorsEnum.RED) -> FilesManager:
	input_command = inputs.get_command('tif,tif,tif,tif,tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='movl6', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o movl' + ' -s ' + str(color_1.value) + ',' + str(color_2.value) + ',' + str(color_3.value) + ',' + str(color_4.value) + ',' + str(color_5.value) + ',' + str(color_6.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# expands the dimensions of the input image
def mpad(inputs: FilesManager, upper_offset: int = 1, lower_offset: int = 1, left_offset: int = 1, right_offset: int = 1, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='mpad', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o pad' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' -s ' + str(upper_offset) + ',' + str(lower_offset) + ',' + str(left_offset) + ',' + str(right_offset) + ' ' + input_command + ' ' + output_command)
	return outputs


# multiplies each data point in multiplier image by the corresponding data point in input image and returns the product in the corresponding data point of the output image
def mul(inputs: FilesManager, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesManager:
	input_command = inputs.get_command('tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='mul', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o mul' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + input_command + ' ' + output_command)
	return outputs


# expands the dimensions of the input image
def pad(inputs: FilesManager, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='pad', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o pad' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + input_command + ' ' + output_command)
	return outputs


# prints the values of pixels to the text file
def plot_sp(inputs: FilesManager, increment: int = 1, function: Plot_spFunctionEnum = Plot_spFunctionEnum.log) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='plot_sp', formats='txt')
	output_command = outputs.get_command('txt', need_comma=True)
	os.system(prostack_path + ' -o plot_sp' + ' -r ' + str(increment) + ' -s ' + str(function.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# prints the values of pixels along the line to the text file
def ppix(inputs: FilesManager, ac: float = 1.0, bc: float = 0.0, ar: float = 1.0, br: float = 0.0, t0: float = 0.0, tn: float = 1.0) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='ppix', formats='txt,tif')
	output_command = outputs.get_command('txt,tif', need_comma=True)
	os.system(prostack_path + ' -o ppix' + ' -s ' + str(ac) + ',' + str(bc) + ',' + str(ar) + ',' + str(br) + ',' + str(t0) + ',' + str(tn) + ' ' + input_command + ' ' + output_command)
	return outputs


# reads raw image and writes it in tiff format
def raw(inputs: FilesManager, columns: int = 1024, rows: int = 1024, bps: int = 8) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='raw', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o raw' + ' -s ' + str(columns) + ',' + str(rows) + ',' + str(bps) + ' ' + input_command + ' ' + output_command)
	return outputs


# performs morphological reconstruction of the image from the marker image
def reconstruct(inputs: FilesManager, connectivity: ConnectivityEnum = ConnectivityEnum.FOUR) -> FilesManager:
	input_command = inputs.get_command('tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='reconstruct', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o reconstruct' + ' -r ' + str(connectivity.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# reverses columns in the image
def revcol(inputs: FilesManager, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='revcol', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o revcol' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + input_command + ' ' + output_command)
	return outputs


# reverses rows in the image
def revrow(inputs: FilesManager, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='revrow', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o revrow' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + input_command + ' ' + output_command)
	return outputs


# produces the image of round strip that includes all blobs from the second input
def robel(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif,tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='robel', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o robel' + ' ' + input_command + ' ' + output_command)
	return outputs


# divides the image from the second input into sectors
def rogri(inputs: FilesManager, number_of_bins: int = 0, accuracy: float = 0.01) -> FilesManager:
	input_command = inputs.get_command('tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='rogri', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o rogri' + ' -r ' + str(number_of_bins) + ' -p ' + str(accuracy) + ' ' + input_command + ' ' + output_command)
	return outputs


# prints the pixel values from the third input to the text file in polar coordinates
def ropol(inputs: FilesManager, function: Plot_spFunctionEnum = Plot_spFunctionEnum.log) -> FilesManager:
	input_command = inputs.get_command('tif,tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='ropol', formats='txt')
	output_command = outputs.get_command('txt', need_comma=True)
	os.system(prostack_path + ' -o ropol' + ' -s ' + str(function.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# calculates the list of points in polar coordinates that determines the inner and outer borders of the round strip
def ropri(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='ropri', formats='txt')
	output_command = outputs.get_command('txt', need_comma=True)
	os.system(prostack_path + ' -o ropri' + ' ' + input_command + ' ' + output_command)
	return outputs


# computes the rotation angle using invariant moments and rotates the image
def rotate(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='rotate', formats='tif,txt')
	output_command = outputs.get_command('tif,txt', need_comma=True)
	os.system(prostack_path + ' -o rotate' + ' ' + input_command + ' ' + output_command)
	return outputs


# reduces the size of the input image using pixel subsampling
def shrink(inputs: FilesManager, scale_from_0_to_1: float = 0.5) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='shrink', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o shrink' + ' -p ' + str(scale_from_0_to_1) + ' ' + input_command + ' ' + output_command)
	return outputs


# calculates the given statistical estimator of pixel intensities for each blob, listed in the first input that can be generated by the blob operator
def solo(inputs: FilesManager, mask_1: SoloEnum = SoloEnum.NUCLEAR, stat_1: StatisticEnum = StatisticEnum.MEAN, p_1: int = 1, mask_2: SoloEnum = SoloEnum.NUCLEAR, stat_2: StatisticEnum = StatisticEnum.MEAN, p_2: int = 1, mask_3: SoloEnum = SoloEnum.NUCLEAR, stat_3: StatisticEnum = StatisticEnum.MEAN, p_3: int = 1, mask_4: SoloEnum = SoloEnum.NUCLEAR, stat_4: StatisticEnum = StatisticEnum.MEAN, p_4: int = 1, mask_5: SoloEnum = SoloEnum.NUCLEAR, stat_5: StatisticEnum = StatisticEnum.MEAN, p_5: int = 1, output_with_8_bits: str = '-a') -> FilesManager:
	input_command = inputs.get_command('txt,tif,tif,tif,tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='solo', formats='txt')
	output_command = outputs.get_command('txt', need_comma=True)
	os.system(prostack_path + ' -o solo' + ' -s ' + str(mask_1.value) + ',' + str(stat_1.value) + ',' + str(p_1) + ',' + str(mask_2.value) + ',' + str(stat_2.value) + ',' + str(p_2) + ',' + str(mask_3.value) + ',' + str(stat_3.value) + ',' + str(p_3) + ',' + str(mask_4.value) + ',' + str(stat_4.value) + ',' + str(p_4) + ',' + str(mask_5.value) + ',' + str(stat_5.value) + ',' + str(p_5) + ' ' + str(output_with_8_bits) + ' ' + input_command + ' ' + output_command)
	return outputs


# calculates the given statistical estimator of pixel intensities for each blob, listed in the first input that can be generated by the blob operator
def solo3(inputs: FilesManager, mask_1: SoloEnum = SoloEnum.NUCLEAR, stat_1: StatisticEnum = StatisticEnum.MEAN, p_1: int = 1, mask_2: SoloEnum = SoloEnum.NUCLEAR, stat_2: StatisticEnum = StatisticEnum.MEAN, p_2: int = 1, mask_3: SoloEnum = SoloEnum.NUCLEAR, stat_3: StatisticEnum = StatisticEnum.MEAN, p_3: int = 1, output_with_8_bits: str = '-a') -> FilesManager:
	input_command = inputs.get_command('txt,tif,tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='solo3', formats='txt')
	output_command = outputs.get_command('txt', need_comma=True)
	os.system(prostack_path + ' -o solo' + ' -s ' + str(mask_1.value) + ',' + str(stat_1.value) + ',' + str(p_1) + ',' + str(mask_2.value) + ',' + str(stat_2.value) + ',' + str(p_2) + ',' + str(mask_3.value) + ',' + str(stat_3.value) + ',' + str(p_3) + ' ' + str(output_with_8_bits) + ' ' + input_command + ' ' + output_command)
	return outputs


# splits the input color image into three grayscale images, one for each color channel
def splitrgb(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='splitrgb', formats='tif,tif,tif')
	output_command = outputs.get_command('tif,tif,tif', need_comma=True)
	os.system(prostack_path + ' -o splitrgb' + ' ' + input_command + ' ' + output_command)
	return outputs


# generates a structural element file
def strel(window_height: int = 3, window_width: int = 3, shape: ShapeEnum = ShapeEnum.DISK) -> FilesManager:
	input_command = ''
	outputs = FilesManager()
	outputs.create_files(func_name='strel', formats='txt')
	output_command = outputs.get_command('txt', need_comma=True)
	os.system(prostack_path + ' -o strel' + ' -s ' + str(window_height) + ',' + str(window_width) + ',' + str(shape.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# convert structural element to the image
def vstrel(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='vstrel', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o vstrel' + ' ' + input_command + ' ' + output_command)
	return outputs


# filters objects in the binary image according to the shape
def sselect(inputs: FilesManager, max_segment: int = 100, min_segment: int = 10, rule: SselectRuleEnum = SselectRuleEnum.accept, criterion: float = 0.1, connectivity: ConnectivityEnum = ConnectivityEnum.FOUR) -> FilesManager:
	input_command = inputs.get_command('tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='sselect', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o sselect' + ' -p ' + str(criterion) + ' -s ' + str(max_segment) + ',' + str(min_segment) + ',' + str(rule.value) + ' -r ' + str(connectivity.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# generates a binary image by thresholding the input image
def threshold(inputs: FilesManager, threshold_level: float = 10.0, method: ThresholdMethodEnum = ThresholdMethodEnum.plain, process: str = '-r 0') -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='threshold', formats='tif,txt')
	output_command = outputs.get_command('tif,txt', need_comma=True)
	os.system(prostack_path + ' -o threshold' + ' -p ' + str(threshold_level) + ' -s ' + str(method.value) + ' ' + str(process) + ' ' + input_command + ' ' + output_command)
	return outputs


# generates a binary image by thresholding the input image with hysteresis
def hystthresh(inputs: FilesManager, low_threshold: float = 10.0, high_threshold: float = 20.0, segment: int = 10, connectivity: ConnectivityEnum = ConnectivityEnum.FOUR) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='hystthresh', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o hystthresh' + ' -s ' + str(low_threshold) + ',' + str(high_threshold) + ',' + str(segment) + ',' + str(connectivity.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# generates a binary image by thresholding the input image with hysteresis
def hystthresh3d(inputs: FilesManager, low_threshold: float = 10.0, high_threshold: float = 20.0, segment: int = 10, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='hystthresh3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o hystthresh3d' + ' -s ' + str(low_threshold) + ',' + str(high_threshold) + ',' + str(segment) + ',' + str(connectivity.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# rotates image to a given angle (second input) that can be calculated by the rotate (see 8
def turn(inputs: FilesManager, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='turn', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o turn' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + input_command + ' ' + output_command)
	return outputs


# calculates the ratio variancies of pixel values in the first input between and within two classes
def vvarbc(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='vvarbc', formats='txt')
	output_command = outputs.get_command('txt', need_comma=True)
	os.system(prostack_path + ' -o vvarbc' + ' ' + input_command + ' ' + output_command)
	return outputs


# contiguous regions of 'on' pixels surrounded by 'off' pixels (blobs) are stored in the output as the list of pixel indices
def blob(inputs: FilesManager, minimal_number_of_pixels: int = 1, maximal_number_of_pixels: int = 100, maximal_number_of_blobs: int = 1000, connectivity: ConnectivityEnum = ConnectivityEnum.FOUR) -> FilesManager:
	input_command = inputs.get_command('tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='blob', formats='txt')
	output_command = outputs.get_command('txt', need_comma=True)
	os.system(prostack_path + ' -o blob' + ' -s ' + str(minimal_number_of_pixels) + ',' + str(maximal_number_of_pixels) + ',' + str(maximal_number_of_blobs) + ' -r ' + str(connectivity.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# finds regional maxima
def regmax(inputs: FilesManager, minimal_number_of_pixels: int = 1, maximal_number_of_pixels: int = 100, maximal_number_of_blobs: int = 1000, connectivity: ConnectivityEnum = ConnectivityEnum.FOUR) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='regmax', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o regmax' + ' -s ' + str(maximal_number_of_pixels) + ',' + str(minimal_number_of_pixels) + ',' + str(maximal_number_of_blobs) + ',' + str(connectivity.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# finds regional minima
def regmin(inputs: FilesManager, minimal_number_of_pixels: int = 1, maximal_number_of_pixels: int = 100, maximal_number_of_blobs: int = 1000, connectivity: ConnectivityEnum = ConnectivityEnum.FOUR) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='regmin', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o regmin' + ' -s ' + str(maximal_number_of_pixels) + ',' + str(minimal_number_of_pixels) + ',' + str(maximal_number_of_blobs) + ',' + str(connectivity.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# generates a binary image by thresholding the input image
def threshb(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='threshb', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o threshb' + ' ' + input_command + ' ' + output_command)
	return outputs


# sums up the image dimensions that are given by a string of four numbers which are the distances measured in pixels from the image center to its borders
def m_ar_plus(inputs: FilesManager, upper_offset: int = 1, lower_offset: int = 1, left_offset: int = 1, right_offset: int = 1) -> FilesManager:
	input_command = inputs.get_command('txt', need_comma=False)
	outputs = FilesManager()
	outputs.create_files(func_name='m_ar_plus', formats='txt')
	output_command = outputs.get_command('txt', need_comma=False)
	os.system(prostack_path + ' -o m_ar_plus' + ' -s ' + str(upper_offset) + ',' + str(lower_offset) + ',' + str(left_offset) + ',' + str(right_offset) + ' ' + input_command + ' ' + output_command)
	return outputs


# multiplies the image dimensions given by a string of four numbers which are the distances measured in pixels from the image center to its borders
def m_ar_x(inputs: FilesManager, upper_offset: int = 1, lower_offset: int = 1, left_offset: int = 1, right_offset: int = 1) -> FilesManager:
	input_command = inputs.get_command('txt', need_comma=False)
	outputs = FilesManager()
	outputs.create_files(func_name='m_ar_x', formats='txt')
	output_command = outputs.get_command('txt', need_comma=False)
	os.system(prostack_path + ' -o m_ar_x' + ' -s ' + str(upper_offset) + ',' + str(lower_offset) + ',' + str(left_offset) + ',' + str(right_offset) + ' ' + input_command + ' ' + output_command)
	return outputs


# applies the rules to put the image of Drosophila embryo into standard orientation
def apee3d(inputs: FilesManager, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='apee3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o apee3d' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + input_command + ' ' + output_command)
	return outputs


# makes a watershed transformation of an input image
def cwtsd3d(inputs: FilesManager, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='cwtsd3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o cwtsd3d' + ' -r ' + str(connectivity.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# makes a watershed transformation of an input image
def querode(inputs: FilesManager, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX, iterations: int = 1) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='querode', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o querode' + ' -r ' + str(connectivity.value) + ' -s ' + str(iterations) + ' ' + input_command + ' ' + output_command)
	return outputs


# makes a watershed transformation of an input image
def quthicken(inputs: FilesManager, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX, iterations: int = 1) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='quthicken', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o quthicken' + ' -r ' + str(connectivity.value) + ' -s ' + str(iterations) + ' ' + input_command + ' ' + output_command)
	return outputs


# reduces the intensity of salt and pepper noise in an image using the Crimmins complementary hulling algorithm [1]
def despekle3d(inputs: FilesManager, iterations: int = 1) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='despekle3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o despekle3d' + ' -r ' + str(iterations) + ' ' + input_command + ' ' + output_command)
	return outputs


# replaces the value of each pixel in the input image by the Euclidean distance from this pixel to the nearest 'off' pixel
def distance3d(inputs: FilesManager, window: DistanceTransformEnum = DistanceTransformEnum.THREE) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='distance3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o distance3d' + ' -r ' + str(window.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# detects the edges of objects in the input image using the Shen-Castan Detector [5, 6]
def edge3d(inputs: FilesManager, a1: float = 0.76543, a2: float = 0.76543, low_threshold: float = 3, high_threshold: float = 12, window: int = 11, segment: int = 11, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='edge3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o edge3d' + ' -s ' + str(a1) + ',' + str(a2) + ',' + str(low_threshold) + ',' + str(high_threshold) + ',' + str(window) + ',' + str(segment) + ',' + str(connectivity.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# increases the size of the input image using the pixel replication
def expand3d(inputs: FilesManager, scale_from_1: float = 2.0) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='expand3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o expand3d' + ' -p ' + str(scale_from_1) + ' ' + input_command + ' ' + output_command)
	return outputs


# does successive dilations of the input image by the structural element supplied as the second input
def gdilation3d(inputs: FilesManager, repetitions: int = 1) -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='gdilation3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o gdilation3d' + ' -r ' + str(repetitions) + ' ' + input_command + ' ' + output_command)
	return outputs


# performs morphological opening which is the erosion followed by dilation using the structural element supplied as the second input
def gopen3d(inputs: FilesManager, repetitions: int = 1) -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='gopen3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o gopen3d' + ' -r ' + str(repetitions) + ' ' + input_command + ' ' + output_command)
	return outputs


# performs morphological closing which is the dilation followed by erosion using the structural element supplied as the second input
def gclose3d(inputs: FilesManager, repetitions: int = 1) -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='gclose3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o gclose3d' + ' -r ' + str(repetitions) + ' ' + input_command + ' ' + output_command)
	return outputs


# reduces dimensions of the input image
def geometry3d(inputs: FilesManager, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='geometry3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o geometry3d' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + input_command + ' ' + output_command)
	return outputs


# does successive erosions of the input image by the structural element supplied as the second input
def gerosion3d(inputs: FilesManager, repetitions: int = 1) -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='gerosion3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o gerosion3d' + ' -r ' + str(repetitions) + ' ' + input_command + ' ' + output_command)
	return outputs


# performs histogram equalization separately for each pixel using the neighborhood defined by the structural element from the second input
def lheq3d(inputs: FilesManager, repetitions: int = 1) -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='lheq3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o lheq3d' + ' -r ' + str(repetitions) + ' ' + input_command + ' ' + output_command)
	return outputs


# computes pixel by pixel maximum of the images in the stack
def max3d(inputs: FilesManager, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='max3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o max3d' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + input_command + ' ' + output_command)
	return outputs


# reduces the dimensions of the input image
def mcrop3d(inputs: FilesManager, upper_offset: int = 1, lower_offset: int = 1, left_offset: int = 1, right_offset: int = 1, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='mcrop3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o geometry3d' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' -s ' + str(upper_offset) + ',' + str(lower_offset) + ',' + str(left_offset) + ',' + str(right_offset) + ' ' + input_command + ' ' + output_command)
	return outputs


# computes a two dimensional median filter of a structural element over the given image
def median3d(inputs: FilesManager, repetitions: int = 1) -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='median3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o median3d' + ' -r ' + str(repetitions) + ' ' + input_command + ' ' + output_command)
	return outputs


# expands the dimensions of the input image
def mpad3d(inputs: FilesManager, upper_offset: int = 1, lower_offset: int = 1, left_offset: int = 1, right_offset: int = 1, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='mpad3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o pad3d' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' -s ' + str(upper_offset) + ',' + str(lower_offset) + ',' + str(left_offset) + ',' + str(right_offset) + ' ' + input_command + ' ' + output_command)
	return outputs


# multiplies each data point in multiplier image by the corresponding data point in input image and returns the product in the corresponding data point of the output image
def mul3d(inputs: FilesManager, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesManager:
	input_command = inputs.get_command('tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='mul3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o mul3d' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + input_command + ' ' + output_command)
	return outputs


# expands the dimensions of the input image
def pad3d(inputs: FilesManager, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='pad3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o pad3d' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + input_command + ' ' + output_command)
	return outputs


# performs morphological reconstruction of the image from the marker image
def reconstruct3d(inputs: FilesManager, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX) -> FilesManager:
	input_command = inputs.get_command('tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='reconstruct3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o reconstruct3d' + ' -r ' + str(connectivity.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# reverses columns in the image
def revcol3d(inputs: FilesManager, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='revcol3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o revcol3d' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + input_command + ' ' + output_command)
	return outputs


# reverses rows in the image
def revrow3d(inputs: FilesManager, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='revrow3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o revrow3d' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + input_command + ' ' + output_command)
	return outputs


# reduces the size of the input image using pixel subsampling
def shrink3d(inputs: FilesManager, scale_from_0_to_1: float = 0.5) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='shrink3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o shrink3d' + ' -p ' + str(scale_from_0_to_1) + ' ' + input_command + ' ' + output_command)
	return outputs


# splits the input color image into three grayscale images, one for each color channel
def splitlsm(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('lsm', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='splitlsm', formats='tif,tif,tif')
	output_command = outputs.get_command('tif,tif,tif', need_comma=True)
	os.system(prostack_path + ' -o splitlsm' + ' ' + input_command + ' ' + output_command)
	return outputs


# generates a structural element file
def strel3d(window_height: int = 3, window_width: int = 3, window_depth: int = 3, shape_xy: ShapeEnum = ShapeEnum.DISK, shape_yz: ShapeEnum = ShapeEnum.DISK) -> FilesManager:
	input_command = ''
	outputs = FilesManager()
	outputs.create_files(func_name='strel3d', formats='txt')
	output_command = outputs.get_command('txt', need_comma=True)
	os.system(prostack_path + ' -o strel3d' + ' -s ' + str(window_height) + ',' + str(window_width) + ',' + str(window_depth) + ',' + str(shape_xy.value) + ',' + str(shape_yz.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# convert structural element to the image
def vstrel3d(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='vstrel3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o vstrel3d' + ' ' + input_command + ' ' + output_command)
	return outputs


# rotates image to a given angle (second input) that can be calculated by the rotate (see 8
def turn3d(inputs: FilesManager, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='turn3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o turn3d' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + input_command + ' ' + output_command)
	return outputs


# inverts the grayscale values of all pixels in input image
def invert3d(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='invert3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o invert3d' + ' ' + input_command + ' ' + output_command)
	return outputs


# fills the regions of 'off' pixels surrounded by 'on' pixels using a structural element
def chole3d(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='chole3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o chole3d' + ' ' + input_command + ' ' + output_command)
	return outputs


# computes pixel by pixel maximum of the channels in the stack
def maxlsm(inputs: FilesManager, comma_separated_list: str = '0,1,2') -> FilesManager:
	input_command = inputs.get_command('lsm', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='maxlsm', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o maxlsm' + ' -s ' + str(comma_separated_list) + ' ' + input_command + ' ' + output_command)
	return outputs


# extracts one channel from the multichannel LSM image
def diglsm(inputs: FilesManager, channel: int = 0) -> FilesManager:
	input_command = inputs.get_command('lsm', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='diglsm', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o diglsm' + ' -r ' + str(channel) + ' ' + input_command + ' ' + output_command)
	return outputs


# generates a binary image by thresholding the input image
def threshold3d(inputs: FilesManager, threshold_level: float = 10.0, method: ThresholdMethodEnum = ThresholdMethodEnum.plain, process: str = '-r 0') -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='threshold3d', formats='tif,txt')
	output_command = outputs.get_command('tif,txt', need_comma=True)
	os.system(prostack_path + ' -o threshold3d' + ' -p ' + str(threshold_level) + ' -s ' + str(method.value) + ' ' + str(process) + ' ' + input_command + ' ' + output_command)
	return outputs


# filters objects in the binary image according to the shape
def sselect3d(inputs: FilesManager, max_segment: int = 100, min_segment: int = 10, rule: SselectRuleEnum = SselectRuleEnum.accept, criterion: float = 0.1, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX) -> FilesManager:
	input_command = inputs.get_command('tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='sselect3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o sselect3d' + ' -p ' + str(criterion) + ' -s ' + str(max_segment) + ',' + str(min_segment) + ',' + str(rule.value) + ' -r ' + str(connectivity.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# converts the binary image stack to the text file
def vtxt(inputs: FilesManager, format: VtxtFormatEnum = VtxtFormatEnum.xyz, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='vtxt', formats='txt')
	output_command = outputs.get_command('txt', need_comma=True)
	os.system(prostack_path + ' -o vtxt' + ' -s ' + str(format.value) + ' -r ' + str(connectivity.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# performs morphological reconstruction of the stack from the marker image
def rec3dbp(inputs: FilesManager, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX, plane: int = 0) -> FilesManager:
	input_command = inputs.get_command('tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='rec3dbp', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o rec3dbp' + ' -r ' + str(connectivity.value) + ' -s ' + str(plane) + ' ' + input_command + ' ' + output_command)
	return outputs


# extracts one plane from the stack
def getp(inputs: FilesManager, plane: int = 0) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='getp', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o getp' + ' -r ' + str(plane) + ' ' + input_command + ' ' + output_command)
	return outputs


# sets one plane in the stack from the second input
def setp(inputs: FilesManager, plane: int = 0) -> FilesManager:
	input_command = inputs.get_command('tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='setp', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o setp' + ' -r ' + str(plane) + ' ' + input_command + ' ' + output_command)
	return outputs


# breaks volume into two at the selected plane
def pbreak(inputs: FilesManager, plane: int = 0) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='pbreak', formats='tif,tif')
	output_command = outputs.get_command('tif,tif', need_comma=True)
	os.system(prostack_path + ' -o pbreak' + ' -r ' + str(plane) + ' ' + input_command + ' ' + output_command)
	return outputs


#  
def punite(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='punite', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o punite' + ' ' + input_command + ' ' + output_command)
	return outputs


# generates a structural element file
def strel3dw(window_height: int = 3, window_width: int = 3, window_depth: int = 3, window_wall: int = 3, shapexy: ShapeEnum = ShapeEnum.DISK, shapeyz: ShapeEnum = ShapeEnum.DISK) -> FilesManager:
	input_command = ''
	outputs = FilesManager()
	outputs.create_files(func_name='strel3dw', formats='txt')
	output_command = outputs.get_command('txt', need_comma=True)
	os.system(prostack_path + ' -o strel3dw' + ' -s ' + str(window_height) + ',' + str(window_width) + ',' + str(window_depth) + ',' + str(window_wall) + ',' + str(shapexy.value) + ',' + str(shapeyz.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# removes planes from the stack with the specified step
def restack3d(inputs: FilesManager, step: int = 2) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='restack3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o restack3d' + ' -r ' + str(step) + ' ' + input_command + ' ' + output_command)
	return outputs


# produces triangulated surface
def surf3d(inputs: FilesManager, scale_column: float = 1, scale_row: float = 1, scale_plane: float = 1, maximal_penalty_of_edge_removal: float = 1000, minimal_angle: float = 1, format: Surf3dFormatEnum = Surf3dFormatEnum.vtk) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='surf3d', formats='txt')
	output_command = outputs.get_command('txt', need_comma=True)
	os.system(prostack_path + ' -o surf3d' + ' -s ' + str(scale_column) + ',' + str(scale_row) + ',' + str(scale_plane) + ',' + str(maximal_penalty_of_edge_removal) + ',' + str(minimal_angle) + ',' + str(format.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# outputs the description of the shape
def shape(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='shape', formats='txt')
	output_command = outputs.get_command('txt', need_comma=True)
	os.system(prostack_path + ' -o shape' + ' ' + input_command + ' ' + output_command)
	return outputs


# outputs the description of the shape
def shape3d(inputs: FilesManager, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='shape3d', formats='txt')
	output_command = outputs.get_command('txt', need_comma=True)
	os.system(prostack_path + ' -o shape3d' + ' -r ' + str(connectivity.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# averages two images pixel by pixel
def vavg(inputs: FilesManager, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesManager:
	input_command = inputs.get_command('tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='vavg', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o vavg' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + input_command + ' ' + output_command)
	return outputs


# computes pixel by pixel maximum of two input images
def vmax(inputs: FilesManager, dont_assume_12_bits: str = '-b', output_with_8_bits: str = '-a') -> FilesManager:
	input_command = inputs.get_command('tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='vmax', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o vmax' + ' ' + str(dont_assume_12_bits) + ' ' + str(output_with_8_bits) + ' ' + input_command + ' ' + output_command)
	return outputs


# combines three grayscale images into one color image
def vrgb(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif,tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='vrgb', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o vrgb' + ' ' + input_command + ' ' + output_command)
	return outputs


# produces the image of the absolute value of differences between pixel values of input images
def vmabs(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='vmabs', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o vmabs' + ' ' + input_command + ' ' + output_command)
	return outputs


# rotates the stack around the vertical axis
def lv3d(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='lv3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o lv3d' + ' ' + input_command + ' ' + output_command)
	return outputs


# rotates the stack around the vertical axis in the direction opposite to that used in the lv3d (see 8
def rv3d(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='rv3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o rv3d' + ' ' + input_command + ' ' + output_command)
	return outputs


# rotates the stack around the horizontal axis
def tv3d(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='tv3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o tv3d' + ' ' + input_command + ' ' + output_command)
	return outputs


# scales the stack in z direction
def zscale3d(inputs: FilesManager, scale_from_1: float = 2.0) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='zscale3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o zscale3d' + ' -p ' + str(scale_from_1) + ' ' + input_command + ' ' + output_command)
	return outputs


# adds the quantitative data from another channel to the initialized storage
def qu3d(inputs: FilesManager, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX, tag: str = 'channel1') -> FilesManager:
	input_command = inputs.get_command('tif,tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='qu3d', formats='txt')
	output_command = outputs.get_command('txt', need_comma=True)
	os.system(prostack_path + ' -o qu3d' + ' -r ' + str(connectivity.value) + ' -s ' + str(tag) + ' ' + input_command + ' ' + output_command)
	return outputs


# adds the number of blob in the 2nd channel as the tag to the quantitative data for the 1st channel to the initialized storage
def quremask(inputs: FilesManager, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX, tag: str = 'channel1') -> FilesManager:
	input_command = inputs.get_command('tif,tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='quremask', formats='txt')
	output_command = outputs.get_command('txt', need_comma=True)
	os.system(prostack_path + ' -o quremask' + ' -r ' + str(connectivity.value) + ' -s ' + str(tag) + ' ' + input_command + ' ' + output_command)
	return outputs


# adds the number of blob in sorted list
def quresort(inputs: FilesManager, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX, tag: str = 'channel1', index: int = 0, reftag: str = 'refch', newtag: str = 'newch', ascending: str = '0') -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='quresort', formats='txt,tif')
	output_command = outputs.get_command('txt,tif', need_comma=True)
	os.system(prostack_path + ' -o quresort' + ' -r ' + str(connectivity.value) + ' -s ' + str(tag) + ',' + str(index) + ',' + str(reftag) + ',' + str(newtag) + ',' + str(ascending) + ' ' + input_command + ' ' + output_command)
	return outputs


# initializes the storage and adds the quantitative data from one channel
def qu3dinit(inputs: FilesManager, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX, tag: str = 'channel1') -> FilesManager:
	input_command = inputs.get_command('tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='qu3dinit', formats='txt')
	output_command = outputs.get_command('txt', need_comma=True)
	os.system(prostack_path + ' -o qu3d' + ' -r ' + str(connectivity.value) + ' -s ' + str(tag) + ' ' + input_command + ' ' + output_command)
	return outputs


# converts the quantitative data to CSV format
def qu3d2csv(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='qu3d2csv', formats='csv')
	output_command = outputs.get_command('csv', need_comma=True)
	os.system(prostack_path + ' -o qu3d2csv' + ' ' + input_command + ' ' + output_command)
	return outputs


# performs deconvolution of the input image using Richardson-Lucy algorithm
def decsup(inputs: FilesManager, max_num_of_iterations: int = 100, criterion: float = 0.01, lmbd: float = 0.001, psf_type: PSFTypeEnum = PSFTypeEnum.BESSEL) -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='decsup', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o decsup' + ' -s ' + str(max_num_of_iterations) + ',' + str(criterion) + ',' + str(lmbd) + ',' + str(psf_type.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# performs deconvolution of the input image using Richardson-Lucy algorithm
def decsup_i(inputs: FilesManager, max_num_of_iterations: int = 100, criterion: float = 0.01, lmbd: float = 0.001, psf_type: PSFTypeEnum = PSFTypeEnum.BESSEL, psf_parameter: float = 1.07, window: int = -1) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='decsup_i', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o decsup' + ' -s ' + str(max_num_of_iterations) + ',' + str(criterion) + ',' + str(lmbd) + ',' + str(psf_type.value) + ',' + str(psf_parameter) + ',' + str(window) + ' ' + input_command + ' ' + output_command)
	return outputs


# performs a blind deconvolution of the input image
def decbsup(inputs: FilesManager, max_num_of_iterations: int = 100, max_blind_iter: int = 100, criterion: float = 0.01, lmbd: float = 0.001, psf_type: PSFTypeEnum = PSFTypeEnum.BESSEL) -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='decbsup', formats='tif,txt')
	output_command = outputs.get_command('tif,txt', need_comma=True)
	os.system(prostack_path + ' -o decbsup' + ' -s ' + str(max_num_of_iterations) + ',' + str(max_blind_iter) + ',' + str(criterion) + ',' + str(lmbd) + ',' + str(psf_type.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# performs a blind deconvolution of the input image
def decbsup_i(inputs: FilesManager, max_num_of_iterations: int = 100, max_blind_iter: int = 100, criterion: float = 0.01, lmbd: float = 0.001, psf_type: PSFTypeEnum = PSFTypeEnum.BESSEL, psf_parameter: float = 1.07, window: int = -1) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='decbsup_i', formats='tif,txt')
	output_command = outputs.get_command('tif,txt', need_comma=True)
	os.system(prostack_path + ' -o decbsup' + ' -s ' + str(max_num_of_iterations) + ',' + str(max_blind_iter) + ',' + str(criterion) + ',' + str(lmbd) + ',' + str(psf_type.value) + ',' + str(psf_parameter) + ',' + str(window) + ' ' + input_command + ' ' + output_command)
	return outputs


# performs deconvolution of the input image using Wiener filter
def decwiener(inputs: FilesManager, lmbd: float = 0.001, psf_type: PSFTypeEnum = PSFTypeEnum.BESSEL, gamma: float = 1.0, alpha: float = 1.0) -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='decwiener', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o decwiener' + ' -s ' + str(lmbd) + ',' + str(psf_type.value) + ',' + str(gamma) + ',' + str(alpha) + ' ' + input_command + ' ' + output_command)
	return outputs


# performs deconvolution of the input image using Wiener filter
def decwiener_i(inputs: FilesManager, lmbd: float = 0.01, psf_type: PSFTypeEnum = PSFTypeEnum.BESSEL, psf_parameter: float = 1.07, gamma: float = 1.0, alpha: float = 1.0, window: int = -1) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='decwiener_i', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o decwiener' + ' -s ' + str(lmbd) + ',' + str(psf_type.value) + ',' + str(psf_parameter) + ',' + str(gamma) + ',' + str(alpha) + ',' + str(window) + ' ' + input_command + ' ' + output_command)
	return outputs


# performs deconvolution of the input image using Tikhonov-Miller algorithm
def dectm(inputs: FilesManager, lmbd: float = 0.001, psf_type: PSFTypeEnum = PSFTypeEnum.BESSEL, gamma: float = 1.0) -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='dectm', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o dectm' + ' -s ' + str(lmbd) + ',' + str(psf_type.value) + ',' + str(gamma) + ' ' + input_command + ' ' + output_command)
	return outputs


# performs deconvolution of the input image using Tikhonov-Miller algorithm
def dectm_i(inputs: FilesManager, lmbd: float = 0.01, psf_type: PSFTypeEnum = PSFTypeEnum.BESSEL, psf_parameter: float = 1.07, gamma: float = 1.0, window: int = -1) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='dectm_i', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o dectm' + ' -s ' + str(lmbd) + ',' + str(psf_type.value) + ',' + str(psf_parameter) + ',' + str(gamma) + ',' + str(window) + ' ' + input_command + ' ' + output_command)
	return outputs


# performs deconvolution of the input image using inverse filter
def decinv(inputs: FilesManager, lmbd: float = 0.001, psf_type: PSFTypeEnum = PSFTypeEnum.BESSEL, gamma: float = 1.0) -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='decinv', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o decinv' + ' -s ' + str(lmbd) + ',' + str(psf_type.value) + ',' + str(gamma) + ' ' + input_command + ' ' + output_command)
	return outputs


# performs deconvolution of the input image using inverse filter
def decinv_i(inputs: FilesManager, lmbd: float = 0.01, psf_type: PSFTypeEnum = PSFTypeEnum.BESSEL, psf_parameter: float = 1.07, gamma: float = 1.0, window: int = -1) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='decinv_i', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o decinv' + ' -s ' + str(lmbd) + ',' + str(psf_type.value) + ',' + str(psf_parameter) + ',' + str(gamma) + ',' + str(window) + ' ' + input_command + ' ' + output_command)
	return outputs


# calculates the ratio of variancies of pixel values in the image between and within two classes
def vvarbc3d(inputs: FilesManager, output_section: str = 'Statistics', class_1_section: str = 'Shape:1', class_1_data: str = 'channel1', class_2_section: str = 'Shape:2', class_2_data: str = 'channel2') -> FilesManager:
	input_command = inputs.get_command('txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='vvarbc3d', formats='txt')
	output_command = outputs.get_command('txt', need_comma=True)
	os.system(prostack_path + ' -o vvarbc3d' + ' -s ' + str(output_section) + ',' + str(class_1_section) + ',' + str(class_1_data) + ',' + str(class_2_section) + ',' + str(class_2_data) + ' ' + input_command + ' ' + output_command)
	return outputs


# removes background signal form the image
def vrmbg(inputs: FilesManager, bgr_mean_coeff: float = 1.0, bgr_section: str = 'Shape:0', bgr_stdev_coeff: float = 3.0, bgr_data: str = 'channel1') -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='vrmbg', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o vrmbg' + ' -s ' + str(bgr_mean_coeff) + ',' + str(bgr_section) + ',' + str(bgr_stdev_coeff) + ',' + str(bgr_data) + ' ' + input_command + ' ' + output_command)
	return outputs


# removes background signal form the image
def vrmbg_1(inputs: FilesManager, bgr_mean_coeff: float = 1.0, bgr_mean: float = 8.0, bgr_stdev_coeff: float = 3.0, bgr_stdev: float = 7.0) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='vrmbg_1', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o vrmbg' + ' -s ' + str(bgr_mean_coeff) + ',' + str(bgr_mean) + ',' + str(bgr_stdev_coeff) + ',' + str(bgr_stdev) + ' ' + input_command + ' ' + output_command)
	return outputs


# produces the image of the cartesian grid
def grid(inputs: FilesManager, number_of_bins: int = 0) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='grid', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o grid' + ' -r ' + str(number_of_bins) + ' ' + input_command + ' ' + output_command)
	return outputs


# produces the image of the grid
def grid3d_i(inputs: FilesManager, type: Grid3d_iTypeEnum = Grid3d_iTypeEnum.cartesian, cell_height_: float = 1, cell_width_: float = 1, cell_depth_: float = 1, offset_: float = 0.5, criterion: float = 0.01, x_center: float = 100.0, y_center: float = 100.0, z_center: float = 100.0) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='grid3d_i', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o grid3d' + ' -s ' + str(type.value) + ',' + str(cell_height_) + ',' + str(cell_width_) + ',' + str(cell_depth_) + ',' + str(offset_) + ',' + str(criterion) + ',' + str(x_center) + ',' + str(y_center) + ',' + str(z_center) + ' ' + input_command + ' ' + output_command)
	return outputs


# produces the image of the grid
def grid3d(inputs: FilesManager, type: Grid3d_iTypeEnum = Grid3d_iTypeEnum.cartesian, cell_height_: float = 1, cell_width_: float = 1, cell_depth_: float = 1, offset_: float = 0.5, criterion: float = 0.01, shape_section: str = 'Shape:0') -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='grid3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o grid3d' + ' -s ' + str(type.value) + ',' + str(cell_height_) + ',' + str(cell_width_) + ',' + str(cell_depth_) + ',' + str(offset_) + ',' + str(criterion) + ',' + str(shape_section) + ' ' + input_command + ' ' + output_command)
	return outputs


# filters the list of the objects and transforms their coordinates
def qu3dtrans(inputs: FilesManager, shape_section: str = 'Shape:0', center: str = '0', percent: str = '0', min_volume: float = 20.0, max_volume: float = 350.0) -> FilesManager:
	input_command = inputs.get_command('txt,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='qu3dtrans', formats='txt')
	output_command = outputs.get_command('txt', need_comma=True)
	os.system(prostack_path + ' -o qu3dtrans' + ' -s ' + str(shape_section) + ',' + str(center) + ',' + str(percent) + ',' + str(min_volume) + ',' + str(max_volume) + ' ' + input_command + ' ' + output_command)
	return outputs


# produces triangulated surface
def surf3dfull(inputs: FilesManager, scale_column: float = 1, scale_row: float = 1, scale_plane: float = 1, maximal_penalty_of_edge_removal: float = 1000, minimal_angle: float = 1, format: Surf3dFormatEnum = Surf3dFormatEnum.vtk, step_for_y: float = 1, step_for_x: float = 1, step_for_z: float = 1, function: Surf3dfullFunctionEnum = Surf3dfullFunctionEnum.cartesian) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='surf3dfull', formats='txt')
	output_command = outputs.get_command('txt', need_comma=True)
	os.system(prostack_path + ' -o surf3dfull' + ' -s ' + str(scale_column) + ',' + str(scale_row) + ',' + str(scale_plane) + ',' + str(maximal_penalty_of_edge_removal) + ',' + str(minimal_angle) + ',' + str(format.value) + ',' + str(step_for_y) + ',' + str(step_for_x) + ',' + str(step_for_z) + ',' + str(function.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# draws triangulated surface
def surf2vol(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='surf2vol', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o surf2vol' + ' ' + input_command + ' ' + output_command)
	return outputs


# converts an image into a stack using the distance map to determine the z coordinate
def pump3d(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='pump3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o pump3d' + ' ' + input_command + ' ' + output_command)
	return outputs


# converts an image into a stack using the distance map to determine the z coordinate
def pump3d_data(inputs: FilesManager) -> FilesManager:
	input_command = inputs.get_command('tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='pump3d_data', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o pump3d' + ' ' + input_command + ' ' + output_command)
	return outputs


# visualizes the distance image supplied as the first input
def mslice3d(inputs: FilesManager, cell_step_: float = 1, direction: int = 2, shape_section: str = 'Shape:0') -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='mslice3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o mslice3d' + ' -s ' + str(shape_section) + ',' + str(cell_step_) + ',' + str(direction) + ' ' + input_command + ' ' + output_command)
	return outputs


# finds control points for registration using the distance image
def mslicegcp3d(inputs: FilesManager, cell_step_: float = 1, direction: int = 2, slice_direction: int = 2, shape_section: str = 'Shape:0', cell_height_: float = 1, cell_width_: float = 1, cell_depth_: float = 1) -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='mslicegcp3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o mslicegcp3d' + ' -s ' + str(shape_section) + ',' + str(cell_step_) + ',' + str(direction) + ',' + str(slice_direction) + ',' + str(cell_height_) + ',' + str(cell_width_) + ',' + str(cell_depth_) + ' ' + input_command + ' ' + output_command)
	return outputs


# registers two images using control points and moving least squares method
def mlsreg(inputs: FilesManager, alpha: float = 1, type: MlsregTypeEnum = MlsregTypeEnum.affine) -> FilesManager:
	input_command = inputs.get_command('tif,tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='mlsreg', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o mlsreg' + ' -s ' + str(type.value) + ',' + str(alpha) + ' ' + input_command + ' ' + output_command)
	return outputs


# collapses the islands of bright pixels in the binary image to exactly one pixel
def qumark3d(inputs: FilesManager, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='qumark3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o qumark3d' + ' -r ' + str(connectivity.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# paints the binary mask with the intensities from quantitative data
def qumap3d(inputs: FilesManager, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX, channel: str = 'channel1', index: int = 1) -> FilesManager:
	input_command = inputs.get_command('tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='qumap3d', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o qumap3d' + ' -r ' + str(connectivity.value) + ' -s ' + str(channel) + ',' + str(index) + ' ' + input_command + ' ' + output_command)
	return outputs


# labels each object in the registered mask with its index in the unregistered mask
def qurelabel(inputs: FilesManager, alpha: float = 1, type: MlsregTypeEnum = MlsregTypeEnum.affine, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX) -> FilesManager:
	input_command = inputs.get_command('tif,txt,tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='qurelabel', formats='txt')
	output_command = outputs.get_command('txt', need_comma=True)
	os.system(prostack_path + ' -o qurelabel' + ' -s ' + str(type.value) + ',' + str(alpha) + ' -r ' + str(connectivity.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# computes a linear combination of two images pixel by pixel
def vaff(inputs: FilesManager, coeff_1: float = 1.0, coeff_2: float = 1.0, coeff_3: float = 0.0) -> FilesManager:
	input_command = inputs.get_command('tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='vaff', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o vaff' + ' -s ' + str(coeff_1) + ',' + str(coeff_2) + ',' + str(coeff_3) + ' ' + input_command + ' ' + output_command)
	return outputs


# adds the quantitative data from another channel to the initialized storage
def quvu(inputs: FilesManager, connectivity: Connectivity3dEnum = Connectivity3dEnum.SIX, tag: str = 'channel1', cycles: int = 3, vertlim: int = 10, alpha: float = 2.0) -> FilesManager:
	input_command = inputs.get_command('tif,tif,txt', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='quvu', formats='txt')
	output_command = outputs.get_command('txt', need_comma=True)
	os.system(prostack_path + ' -o quvu' + ' -r ' + str(connectivity.value) + ' -s ' + str(tag) + ',' + str(vertlim) + ',' + str(alpha) + ' -p ' + str(cycles) + ' ' + input_command + ' ' + output_command)
	return outputs


# combines six grayscale images into one color image
def movl8(inputs: FilesManager, color_1: ColorsEnum = ColorsEnum.RED, color_2: ColorsEnum = ColorsEnum.RED, color_3: ColorsEnum = ColorsEnum.RED, color_4: ColorsEnum = ColorsEnum.RED, color_5: ColorsEnum = ColorsEnum.RED, color_6: ColorsEnum = ColorsEnum.RED, color_7: ColorsEnum = ColorsEnum.RED, color_8: ColorsEnum = ColorsEnum.RED) -> FilesManager:
	input_command = inputs.get_command('tif,tif,tif,tif,tif,tif,tif,tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='movl8', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + ' -o movl' + ' -s ' + str(color_1.value) + ',' + str(color_2.value) + ',' + str(color_3.value) + ',' + str(color_4.value) + ',' + str(color_5.value) + ',' + str(color_6.value) + ',' + str(color_7.value) + ',' + str(color_8.value) + ' ' + input_command + ' ' + output_command)
	return outputs


# 
def convert(inputs: FilesManager, channel: str = 'R') -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='convert', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + 'convert' + ' -depth 8 -channel ' + str(channel) + ' -separate' + ' ' + input_command + ' ' + output_command)
	return outputs


# this method subtracts pixels from the original image to reduce the shapes into skeletons
def thinning(inputs: FilesManager, iterations: int = -1) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='thinning', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + 'convert' + ' -depth 8 -morphology Thinning:' + str(iterations) + ' Diagonals -morphology Thinning Corners' + ' ' + input_command + ' ' + output_command)
	return outputs


# this method correlates image with gaussian
def correlate(inputs: FilesManager, radius: int = 0, sigma: float = 1.0) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='correlate', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + 'convert' + ' -define convolve:scale="1^" -morphology Correlate Gaussian:' + str(radius) + 'x' + str(sigma) + ' -depth 8' + ' ' + input_command + ' ' + output_command)
	return outputs


# convolution with Laplacian of gaussians
def LoG(inputs: FilesManager, radius: int = 0, sigma: float = 1.0) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='LoG', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + 'convert' + ' -define -morphology Convolve LoG:' + str(radius) + ',' + str(sigma) + ' -depth 8' + ' ' + input_command + ' ' + output_command)
	return outputs


# convolution with difference of gaussians
def DoG(inputs: FilesManager, radius: int = 0, sigma_1: float = 1.0, sigma_2: float = 1.5) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='DoG', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + 'convert' + ' -define -morphology Convolve DoG:' + str(radius) + ',' + str(sigma_1) + ',' + str(sigma_2) + ' -depth 8' + ' ' + input_command + ' ' + output_command)
	return outputs


# implements the Canny algorithm for edge detection
def imcanny(inputs: FilesManager, radius: float = 0, sigma: float = 1, low_frac: float = 0.1, upper_frac: str = '0.3') -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='imcanny', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + 'convert -canny' + ' ' + str(radius) + 'x' + str(sigma) + '+' + str(low_frac) + '+' + str(upper_frac) + ' -depth 8' + ' ' + input_command + ' ' + output_command)
	return outputs


#  
def lat(inputs: FilesManager, radius: int = 10) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='lat', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + 'convert -lat' + ' ' + str(radius) + ' -depth 8' + ' ' + input_command + ' ' + output_command)
	return outputs


# convolution with Laplacian kernel
def laplacian(inputs: FilesManager, type: int = 0, scale: str = '-1!', bias: float = 0.5) -> FilesManager:
	input_command = inputs.get_command('tif', need_comma=True)
	outputs = FilesManager()
	outputs.create_files(func_name='laplacian', formats='tif')
	output_command = outputs.get_command('tif', need_comma=True)
	os.system(prostack_path + 'convert' + ' -define convolve:scale="' + str(scale) + '" -bias ' + str(bias) + ' -morphology Convolve Laplacian:' + str(type) + ' ' + input_command + ' ' + output_command)
	return outputs


